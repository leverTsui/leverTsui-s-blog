<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[读《大话设计模式》]]></title>
    <url>%2F2018%2F07%2F13%2F%E8%AF%BB%E3%80%8A%E5%A4%A7%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B%2F</url>
    <content type="text"><![CDATA[前言对设计模式的理解，不够透彻，有时去找资料，总是零零散散，不成系统，故将《大话设计模式》中的干货整理下，方便需要使用时参阅。设计模式六大原则单一职责原则定义：就一个类而言，应该仅有一个引起它变化的原因。通俗的说，即一个类只负责一项职责。问题由来：类T负责两个不同的职责：职责P1，职责P2。当由于职责P1需求发生改变而需要修改类T时，有可能会导致原本运行正常的职责P2功能发生故障。解决方案：遵循单一职责原则。分别建立两个类T1、T2，使T1完成职责P1功能，T2完成职责P2功能。这样，当修改类T1时，不会使职责P2发生故障风险；同理，当修改T2时，也不会使职责P1发生故障风险。最佳实践：可以降低类的复杂度，一个类只负责一项职责，其逻辑肯定要比负责多项职责简单的多；提高类的可读性，提高系统的可维护性；降低需求变更引起的风险。里氏替换原则-定义：子类型必须能够替换掉它们的父类型。问题由来：有一功能P1，由类A完成。现需要将功能P1进行扩展，扩展后的功能为P，其中P由原有功能P1与新功能P2组成。新功能P由类A的子类B来完成，则子类B在完成新功能P2的同时，有可能会导致原有功能P1发生故障。解决方案：当使用继承时，遵循里氏替换原则。类B继承类A时，除添加新的方法完成新增功能P2外，尽量不要重写父类A的方法，也尽量不要重载父类A的方法。依赖倒转原则定义：A.高层模块不应该依赖底层模块。两者都应该依赖抽象。B.抽象不应该依赖细节。细节应该依赖抽象。 通俗理解：针对接口编程，不要针对实现编程。 问题由来：类A直接依赖类B，假如要将类A改为依赖类C，则必须通过修改类A的代码来达成。这种场景下，类A一般是高层模块，负责复杂的业务逻辑；类B和类C是低层模块，负责基本的原子操作；假如修改类A，会给程序带来不必要的风险。解决方案：将类A修改为依赖接口I，类B和类C各自实现接口I，类A通过接口I间接与类B或者类C发生联系，则会大大降低修改类A的几率。最佳实践：低层模块尽量都要有抽象类或接口，或者抽象类或接口两者都具备。变量的声明类型尽量是抽象类或接口。使用继承时遵循里氏替换原则。接口隔离原则定义：一个类对另一个类的依赖，应该建立在最小的接口上。问题由来：类A通过接口I依赖类B，类C通过接口I依赖类D，如果接口I对于类A和类B来说不是最小接口，则类B和类D必须去实现他们不需要的方法。解决方案：将臃肿的接口I拆分为独立的几个接口，类A和类C分别与他们需要的接口建立依赖关系。也就是采用接口隔离原则。最佳实践：接口尽量小，但是要有限度。对接口进行细化可以提高程序设计灵活性是不挣的事实，但是如果过小，则会造成接口数量过多，使设计复杂化。所以一定要适度；为依赖接口的类定制服务，只暴露给调用的类它需要的方法，它不需要的方法则隐藏起来。只有专注地为一个模块提供定制服务，才能建立最小的依赖关系；提高内聚，减少对外交互。使接口用最少的方法去完成最多的事情；适度使用，接口设计的过大或过小都不好。迪米特法则定义：又叫最少知道原则，如果两个类不必彼此直接通信，那么这两个类就不应当发生直接的相互作用。如果其中一个类需要调用另一个类的某一个方法的话，可以通过第三者转发这个调用。一个对象应该对其他对象保持最少的了解。问题由来：类与类之间的关系越密切，耦合度越大，当一个类发生改变时，对另一个类的影响也越大。最佳实践：尽量降低类与类之间的耦合。可以通过第三者来进行通信。开放-封闭原则定义：软件实体（类、模块、函数等等）应该可以扩展，但是不可修改。问题由来：在软件的生命周期内，因为变化、升级和维护等原因需要对软件原有代码进行修改时，可能会给旧代码中引入错误，也可能会使我们不得不对整个功能进行重构，并且需要原有代码经过重新测试。解决方案：当软件需要变化时，尽量通过扩展软件实体的行为来实现变化，而不是通过修改已有的代码来实现变化。六大原则总结用抽象构建框架，用实现扩展细节。单一职责原则告诉我们实现类要职责单一；里氏替换原则告诉我们不要破坏继承体系；依赖倒置原则告诉我们要面向接口编程；接口隔离原则告诉我们在设计接口的时候要精简单一；迪米特法则告诉我们要降低耦合。而开闭原则是总纲，它告诉我们要对扩展开放，对修改关闭。设计模式六大原则UML基础知识类与类之间的关系泛化：是一种继承关系，表示一般与特殊的关系，存在于父类与子类、父接口与子接口之间，表示子类如何特化父类的所有特征和行为，比如动物和鸟之间的关系；实现：一种类与接口的关系，表示类对接口所有特征和行为的实现，比如大雁与接口飞翔的关系；组合：是一种强的‘拥有’关系，体现了严格的整体和部分的关系，部分和整体的生命周期一样，比如鸟与翅膀的关系；聚合：是一种弱的‘拥有’关系，体现的是A对象可以包含B对象，但B对象不是A对象的一部分，比如雁群和大雁的关系；关联：描述了类与类之间的结构化关系，具有方向、名字、角色和多重性等信息，是一种拥有的关系，它使一个类知道另一个类的属性和方法，比如企鹅与气候的关系，人与住址的关系；依赖：是一种使用关系，特定事物的改变有可能会影响到使用该事物的其他事物，表示一个事物使用另一个事物时使用依赖关系。大多数情况下，依赖关系体现在某个类的方法使用另一个类的对象作为参数。1、将一个类的对象作为另一个类中方法的参数2、在一个类的方法中将另一个类的对象作为其局部变量3、在一个类的方法中调用另一个类的静态方法。各种关系的强弱顺序：泛化 = 实现 &gt; 组合 &gt; 聚合 &gt; 关联 &gt; 依赖常用的23中设计模式创建型模式简单工厂模式模式动机考虑一个简单的软件应用场景，一个计算器有不同的按钮（如+、-、*、÷）， 这些按钮都源自同一个基类，不过在继承基类后不同的子类修改了部分属性从而使得它们可以完成不同的功能，如果我们希望在使用这些按钮时，不需要知道这些具体按钮类的名字，只需要知道表示该按钮类的一个参数，并提供一个调用方便的方法，把该参数传入方法即可返回一个相应的按钮对象，此时，就可以使用简单工厂模式。模式定义简单工厂模式(Simple Factory Pattern)：它属于类创建型模式。在简单工厂模式中，可以根据参数的不同返回不同类的实例。简单工厂模式专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。模式结构简单工厂模式包含如下角色：HCDCalcuteFactory：工厂角色工厂角色负责实现创建所有实例的内部逻辑HCDCalculate：抽象产品角色抽象产品角色是所创建的所有对象的父类，负责描述所有实例所共有的公共接口HCDCalculateAdd：具体产品角色具体产品角色是创建目标，所有创建的对象都充当这个角色的某个具体类的实例。时序图源码1234567891011121314151617//HCDCalculateProtocol.h#import &lt;Foundation/Foundation.h&gt;#import &lt;UIKit/UIKit.h&gt;typedef NS_ENUM(NSInteger, HCDCalculateType) &#123; HCDCalculateTypeAdd = 0, //加 HCDCalculateTypeMinus, //减 HCDCalculateTypeMultipy, //乘 HCDCalculateTypeDivide //除&#125;;@protocol HCDCalculateProtocol &lt;NSObject&gt;@optional-(CGFloat)calculate;@end1234567891011//HCDCalculate.h#import &lt;Foundation/Foundation.h&gt;#import &lt;UIKit/UIKit.h&gt;#import "HCDCalculateProtocol.h"@interface HCDCalculate : NSObject &lt;HCDCalculateProtocol&gt;@property(nonatomic, assign) CGFloat numberA;@property(nonatomic, assign) CGFloat numberB;@end12345678910111213141516171819202122232425262728293031323334353637383940414243//HCDCalcuteFactory.h#import &lt;Foundation/Foundation.h&gt;#import "HCDCalculate.h"@interface HCDCalcuteFactory : NSObject+(HCDCalculate *)createCalcute:(NSString *)calculatetype;@end//HCDCalcuteFactory.m#import "HCDCalcuteFactory.h"#import "HCDCalculateAdd.h"#import "HCDCalculateDivide.h"#import "HCDCalculateMinus.h"#import "HCDCalcuteMultiply.h"@implementation HCDCalcuteFactory+(HCDCalculate *)createCalcute:(NSString *)calculatetype &#123; NSArray *calculateArray = @[@"+",@"-",@"*",@"/"]; if (![calculateArray containsObject:calculatetype]) &#123; return nil; &#125; HCDCalculateType calType = [calculateArray indexOfObject:calculatetype]; switch (calType) &#123; case HCDCalculateTypeAdd: return [[HCDCalculateAdd alloc]init]; break; case HCDCalculateTypeMinus: return [[HCDCalculateMinus alloc]init]; break; case HCDCalculateTypeMultipy: return [[HCDCalcuteMultiply alloc]init]; case HCDCalculateTypeDivide: return [[HCDCalculateDivide alloc]init]; &#125;&#125;@end123456789101112131415161718192021222324252627282930313233343536373839404142434445//HCDCalculateAdd.m#import "HCDCalculateAdd.h"@implementation HCDCalculateAdd-(CGFloat)calculate&#123; return self.numberA + self.numberB;&#125;@end//HCDCalculateMinus.m#import "HCDCalculateMinus.h"@implementation HCDCalculateMinus-(CGFloat)calculate&#123; return self.numberA - self.numberB;&#125;@end//HCDCalcuteMultiply#import "HCDCalcuteMultiply.h"@implementation HCDCalcuteMultiply-(CGFloat)calculate&#123; return self.numberA * self.numberB;&#125;@end//HCDCalculateDivide.m#import "HCDCalculateDivide.h"@implementation HCDCalculateDivide- (CGFloat)calculate&#123; if (self.numberB == 0) &#123; NSLog(@"dividend is can not be zero!"); return 0; &#125; return self.numberA/self.numberB;&#125;@end工厂方法模式模式动机现在对该系统进行修改，不再设计一个运算工厂类来统一负责所有产品的创建，而是将具体运算的创建过程交给专门的工厂子类去完成，我们先定义一个抽象的运算工厂类，再定义具体的工厂类来生成加法运算、减法运算、乘法运算等，它们实现在抽象按钮工厂类中定义的方法。这种抽象化的结果使这种结构可以在不修改具体工厂类的情况下引进新的产品，如果出现新的按钮类型，只需要为这种新类型的按钮创建一个具体的工厂类就可以获得该新运算的实例，这一特点无疑使得工厂方法模式具有超越简单工厂模式的优越性，更加符合“开闭原则”。模式定义工厂方法模式，它属于类创建型模式。在工厂方法模式中，工厂父类负责定义创建产品对象的公共接口，而工厂子类则负责生成具体的产品对象，这样做的目的是将产品类的实例化操作延迟到工厂子类中完成，即通过工厂子类来确定究竟应该实例化哪一个具体产品类。模式结构工厂方法模式包含如下角色：HCDCalculate：抽象产品HCDCalculateAdd：具体产品HCDfactory：抽象工厂HCDfactoryAdd：具体工厂时序图源码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253//HCDfactory.h#import &lt;Foundation/Foundation.h&gt;#import "HCDCalculate.h"@interface HCDfactory : NSObject-(HCDCalculate *)createFactory;@end//HCDfactory.m#import "HCDfactory.h"@implementation HCDfactory-(HCDCalculate *)createFactory &#123; return nil;&#125;@end//HCDfactoryAdd.m@implementation HCDfactoryAdd-(HCDCalculate *)createFactory &#123; return [[HCDCalculateAdd alloc]init];&#125;@end//HCDfactoryMinus.m@implementation HCDfactoryMinus-(HCDCalculate *)createFactory &#123; return [[HCDCalculateMinus alloc]init];&#125;@end//HCDfactoryMultiply.m@implementation HCDfactoryMultiply-(HCDCalculate *)createFactory &#123; return [[HCDCalcuteMultiply alloc]init];&#125;@end//HCDfactoryDivide.m@implementation HCDfactoryDivide-(HCDCalculate *)createFactory &#123; return [[HCDCalculateDivide alloc]init];&#125;@end123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960//HCDCalculate.h@interface HCDCalculate : NSObject &lt;HCDCalculateProtocol&gt;@property(nonatomic, assign) CGFloat numberA;@property(nonatomic, assign) CGFloat numberB;@end//HCDCalculateAdd.m@implementation HCDCalculateAdd-(CGFloat)calculate&#123; return self.numberA + self.numberB;&#125;@end//HCDCalculateMinus.m@implementation HCDCalculateMinus-(CGFloat)calculate&#123; return self.numberA - self.numberB;&#125;@end//HCDCalcuteMultiply.m@implementation HCDCalcuteMultiply-(CGFloat)calculate&#123; return self.numberA * self.numberB;&#125;@end//HCDCalculateDivide.m@implementation HCDCalculateDivide- (CGFloat)calculate&#123; if (self.numberB == 0) &#123; NSLog(@"dividend is can not be zero!"); return 0; &#125; return self.numberA/self.numberB;&#125;@end//HCDCalculateProtocol.htypedef NS_ENUM(NSInteger, HCDCalculateType) &#123; HCDCalculateTypeAdd = 0, //加 HCDCalculateTypeMinus, //减 HCDCalculateTypeMultipy, //乘 HCDCalculateTypeDivide //除&#125;;@protocol HCDCalculateProtocol &lt;NSObject&gt;@optional-(CGFloat)calculate;@end123456789101112131415161718192021222324//使用示例 HCDfactory *addFactory = [[HCDfactoryAdd alloc]init]; HCDCalculate *addCalculate = [addFactory createFactory]; addCalculate.numberA = 10; addCalculate.numberB = 15; NSLog(@"结果是%f\n",[addCalculate calculate]); HCDfactory *minusFactory = [[HCDfactoryMinus alloc]init]; HCDCalculate *minusCalculate = [minusFactory createFactory]; minusCalculate.numberA = 10; minusCalculate.numberB = 15; NSLog(@"结果是%f\n",[minusCalculate calculate]); HCDfactory *multiplyFactory = [[HCDfactoryMultiply alloc]init]; HCDCalculate *multiplyCalculate = [multiplyFactory createFactory]; multiplyCalculate.numberA = 10; multiplyCalculate.numberB = 15; NSLog(@"结果是%f\n",[multiplyCalculate calculate]); HCDfactory *divideFactory = [[HCDfactoryDivide alloc]init]; HCDCalculate *divideCalculate = [divideFactory createFactory]; divideCalculate.numberA = 10; divideCalculate.numberB = 15; NSLog(@"结果是%f\n",[divideCalculate calculate]);抽象工厂模式模式动机在工厂方法模式中具体工厂负责生产具体的产品，每一个具体工厂对应一种具体产品，工厂方法也具有唯一性，一般情况下，一个具体工厂中只有一个工厂-方法或者一组重载的工厂方法。但是有时候我们需要一个工厂可以提供多个产品对象，而不是单一的产品对象。当系统所提供的工厂所需生产的具体产品并不是一个简单的对象，而是多个位于不同产品等级结构中属于不同类型的具体产品时需要使用抽象工厂模式。模式定义抽象工厂模式：提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。属于对象创建型模式。模式结构抽象工厂模式包含如下角色：HCDFactory：抽象工厂HCDSqlserverFactory：具体工厂HCDDepartment：抽象产品HCDSqlserverDepartment：具体产品时序图源码12345678910111213141516171819202122232425262728293031//HCDFactory.h@protocol HCDFactory &lt;NSObject&gt;-(id&lt;HCDUser&gt;)createUser;-(id&lt;HCDDepartment&gt;)createDepartment;@end//HCDSqlserverFactory.m@implementation HCDSqlserverFactory-(id&lt;HCDUser&gt;)createUser&#123; return [[HCDSqlserverUser alloc]init];&#125;-(id&lt;HCDDepartment&gt;)createDepartment&#123; return [[HCDSqlserverDepartment alloc]init];&#125;@end//HCDAccessFactory.m-(id&lt;HCDUser&gt;)createUser&#123; return [[HCDAccessUser alloc]init];&#125;-(id&lt;HCDDepartment&gt;)createDepartment&#123; return [[HCDAccessDepartment alloc]init];&#125;@end123456789101112131415161718192021222324252627282930313233343536//HCDDepartment.h@protocol HCDDepartment &lt;NSObject&gt;-(void)insertDepartment:(SQLDepartment *)department;-(SQLDepartment *)getDepartment;@end//HCDSqlserverDepartment.m@implementation HCDSqlserverDepartment-(SQLDepartment *)getDepartment&#123; NSLog(@"新建一个Sqlserver的SQLDepartment对象"); return [[SQLDepartment alloc]init];&#125;-(void)insertDepartment:(SQLDepartment *)department&#123; NSLog(@"插入一个Sqlserver的SQLDepartment对象");&#125;@end//HCDAccessDepartment.m@implementation HCDAccessDepartment-(SQLDepartment *)getDepartment&#123; NSLog(@"新建一个Access的SQLDepartment对象"); return [[SQLDepartment alloc]init];&#125;-(void)insertDepartment:(SQLDepartment *)department&#123; NSLog(@"插入一个Access的SQLDepartment对象");&#125;@end123456789101112131415161718192021222324252627282930313233343536//HCDUser.h@protocol HCDUser &lt;NSObject&gt;-(void)insertUser:(SQLUser *)user;-(SQLUser *)getUser;@end//HCDSqlserverUser.m@implementation HCDSqlserverUser-(SQLUser *)getUser&#123; NSLog(@"新建一个Sqlserver的SQLUser对象"); return [[SQLUser alloc]init];&#125;-(void)insertUser:(SQLUser *)user&#123; NSLog(@"插入一个Sqlserver的SQLUser对象");&#125;@end//HCDAccessUser.m@implementation HCDAccessUser-(SQLUser *)getUser&#123; NSLog(@"新建一个Access的SQLUser对象"); return [[SQLUser alloc]init];&#125;-(void)insertUser:(SQLUser *)user&#123; NSLog(@"插入一个Access的SQLUser对象");&#125;@end123456789101112131415161718//使用示例 id&lt;HCDFactory&gt; factory0 = [[HCDSqlserverFactory alloc]init]; id&lt;HCDDepartment&gt; department0 = [factory0 createDepartment]; [department0 insertDepartment:[[SQLDepartment alloc]init]]; [department0 getDepartment]; id&lt;HCDUser&gt; user0 = [factory0 createUser]; [user0 insertUser:[[SQLUser alloc] init]]; [user0 getUser]; id&lt;HCDFactory&gt; factory1 = [[HCDAccessFactory alloc]init]; id&lt;HCDDepartment&gt; department1 = [factory1 createDepartment]; [department1 insertDepartment:[[SQLDepartment alloc]init]]; [department1 getDepartment]; id&lt;HCDUser&gt; user1 = [factory1 createUser]; [user1 insertUser:[[SQLUser alloc] init]]; [user1 getUser];建造者模式模式动机无论是在现实世界中还是在软件系统中，都存在一些复杂的对象，它们拥有多个组成部分，如汽车，它包括车轮、方向盘、发送机等各种部件。而对于大多数用户而言，无须知道这些部件的装配细节，也几乎不会使用单独某个部件，而是使用一辆完整的汽车，可以通过建造者模式对其进行设计与描述，建造者模式可以将部件和其组装过程分开，一步一步创建一个复杂的对象。用户只需要指定复杂对象的类型就可以得到该对象，而无须知道其内部的具体构造细节。模式定义造者模式：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。模式结构建造者模式包含如下角色：HCDPresionBuilder：抽象建造者HCDPersonFatBuilder：具体建造者HCDPersonBuilderDirector：指挥者HCDProduct：产品角色时序图源码1234567891011121314151617181920212223242526272829303132333435363738//HCDPersonBuilderDirector.h@class HCDPresionBuilder;@interface HCDPersonBuilderDirector : NSObject- (instancetype)initWithBuilder:(HCDPresionBuilder *)builder;- (void)buildPerson; @end//HCDPersonBuilderDirector.m@interface HCDPersonBuilderDirector ()@property (nonatomic, strong) HCDPresionBuilder *builder;@end@implementation HCDPersonBuilderDirector- (instancetype)initWithBuilder:(HCDPresionBuilder *)builder &#123; self = [super init]; if (self) &#123; self.builder = builder; &#125; return self;&#125;- (void)buildPerson &#123; [self.builder buildHead]; [self.builder buildBody]; [self.builder buildArmLeft]; [self.builder buildArmRight]; [self.builder buildLegLeft]; [self.builder buildLegRight]; [self.builder getResult];&#125;@end123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143//HCDPresionBuilderProtocol.hypedef NS_ENUM(NSUInteger,HCDBuildOption)&#123; HCDBuildOptionFat = 0, //胖的人 HCDBuildOptionThin //瘦的人&#125;;@protocol HCDPresionBuilderProtocol &lt;NSObject&gt;- (void)buildHead;- (void)buildBody;- (void)buildArmLeft;- (void)buildArmRight;- (void)buildLegLeft;- (void)buildLegRight;- (HCDProduct *)getResult;@end //HCDPresionBuilder.h@interface HCDPresionBuilder : NSObject&lt;HCDPresionBuilderProtocol&gt;@end//HCDPersonFatBuilder.m@interface HCDPersonFatBuilder()@property (nonatomic, strong) HCDProduct *product;@end@implementation HCDPersonFatBuilder-(instancetype)init&#123; self = [super init]; if (self) &#123; _product = [[HCDProduct alloc] init]; &#125; return self;&#125; - (void)buildHead &#123; NSLog(@"建造胖子的头部"); [self.product.header work];&#125;- (void)buildBody &#123; NSLog(@"建造胖子的身体"); [self.product.body work];&#125;- (void)buildArmLeft &#123; NSLog(@"建造胖子的左手"); [self.product.arm work];&#125;- (void)buildArmRight &#123; NSLog(@"建造胖子的右手"); [self.product.arm work];&#125;- (void)buildLegLeft &#123; NSLog(@"建造胖子的左脚"); [self.product.leg work];&#125;- (void)buildLegRight &#123; NSLog(@"建造胖子的右脚"); [self.product.leg work];&#125;- (HCDProduct *)getResult &#123; return self.product;&#125;@end//HCDPersonThinBuilder.m@interface HCDPersonThinBuilder ()@property (nonatomic, strong) HCDProduct *product;@end@implementation HCDPersonThinBuilder-(instancetype)init&#123; self = [super init]; if (self) &#123; _product = [[HCDProduct alloc] init]; &#125; return self;&#125; - (void)buildHead &#123; NSLog(@"建造瘦子的头部"); [self.product.header work];&#125;- (void)buildBody &#123; NSLog(@"建造瘦子的身体"); [self.product.body work];&#125;- (void)buildArmLeft &#123; NSLog(@"建造瘦子的左手"); [self.product.arm work];&#125;- (void)buildArmRight &#123; NSLog(@"建造瘦子的右手"); [self.product.arm work];&#125;- (void)buildLegLeft &#123; NSLog(@"建造瘦子的左脚"); [self.product.leg work];&#125;- (void)buildLegRight &#123; NSLog(@"建造瘦子的右脚"); [self.product.leg work];&#125;- (HCDProduct *)getResult &#123; return self.product;&#125;@end``` ```objc//使用示例- (IBAction)buildFat:(id)sender &#123; HCDPersonFatBuilder *builder = [[HCDPersonFatBuilder alloc]init]; HCDPersonBuilderDirector *director = [[HCDPersonBuilderDirector alloc] initWithBuilder:builder]; [director buildPerson];&#125;- (IBAction)buildThin:(id)sender &#123; HCDPersonThinBuilder *builder = [[HCDPersonThinBuilder alloc]init]; HCDPersonBuilderDirector *director = [[HCDPersonBuilderDirector alloc] initWithBuilder:builder]; [director buildPerson];&#125;单例模式模式动机对于系统中的某些类来说，只有一个实例很重要，例如，一个系统中可以存在多个打印任务，但是只能有一个正在工作的任务；一个系统只能有一个窗口管理器或文件系统；一个系统只能有一个计时工具或ID（序号）生成器。如何保证一个类只有一个实例并且这个实例易于被访问呢？定义一个全局变量可以确保对象随时都可以被访问，但不能防止我们实例化多个对象。一个更好的解决办法是让类自身负责保存它的唯一实例。这个类可以保证没有其他实例被创建，并且它可以提供一个访问该实例的方法。这就是单例模式的模式动机模式定义单例模式：单例模式确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类称为单例类，它提供全局访问的方法。模式结构时序图源码12345678+(instancetype)sharedInstance&#123; static HCDSingleton *singleton = nil; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; singleton = [[HCDSingleton alloc]init]; &#125;); return singleton;&#125;原型模式模式动机将一个原型对象传给那个要发动创建的对象，这个要发动创建的对象通过请求原型对象拷贝自己来实现创建过程。通过克隆方法所创建的对象是全新的对象，它们在内存中拥有新的地址，通常对克隆所产生的对象进行修改对原型对象不会造成任何影响，每一个克隆对象都是相互独立的。通过不同的方式修改可以得到一系列相似但不完全相同的对象。模式定义使用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。原型模式是一种对象创建型模式。备注：复制分浅复制和深复制浅复制：被复制对象的所有变量都含有与原来的对象相同的值，而所有的对其他对象的引用都仍然指向原来的对象；深复制：把引用对象的变量指向复制过的新对象，而不是原有的被引用的对象。iOS深拷贝和浅拷贝结构式模式组合模式模式动机对于树形结构，当容器对象的某一个方法被调用时，将遍历整个树形结构，寻找也包含这个方法的成员对象（可以是容器对象，也可以是叶子对象，如子文件夹和文件）并调用执行。（递归调用）由于容器对象和叶子对象在功能上的区别，在使用这些对象的客户端代码中必须有区别地对待容器对象和叶子对象，而实际上大多数情况下客户端希望一致地处理它们，因为对于这些对象的区别对待将会使得程序非常复杂。组合模式描述了如何将容器对象和叶子对象进行递归组合，使得用户在使用时无须对它们进行区分，可以一致地对待容器对象和叶子对象，这就是组合模式的模式动机。模式定义将对象组合成树形结构以表示‘部分-整体’的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。模式结构模板方法模式包含如下角色：Component: 对象声明接口Leaf: 叶节点对象Composite: 枝节点行为时序图略源码1234567891011121314151617181920//使用示例HCDConcreteCompany *root = [[HCDConcreteCompany alloc] initWithName:@"总公司"];[root add:[[HCDHRDepartment alloc] initWithName:@"总公司人力资源部"]];[root add:[[HCDFinanceDepartment alloc] initWithName:@"总公司财务部"]];HCDConcreteCompany *comp = [[HCDConcreteCompany alloc] initWithName:@"上海华东分公司"];[comp add:[[HCDHRDepartment alloc] initWithName:@"上海华东分公司人力资源部"]];[comp add:[[HCDFinanceDepartment alloc] initWithName:@"上海华东分公司财务部"]];[root add:comp];HCDConcreteCompany *office = [[HCDConcreteCompany alloc] initWithName:@"杭州办事处"];[office add:[[HCDHRDepartment alloc] initWithName:@"杭州办事处人力资源部"]];[office add:[[HCDFinanceDepartment alloc] initWithName:@"杭州办事处财务部"]];NSLog(@"\n");[comp add:office];NSLog(@"结构图:--------------------------");[root display:1];NSLog(@"\n");NSLog(@"职责:---------------------------");[root lineofDuty];12345678910111213141516//HCDCompany.h@interface HCDCompany : NSObject@property (nonatomic,copy) NSString *name;- (instancetype)initWithName:(NSString *)name;-(void)add:(HCDCompany *)company;-(void)remove:(HCDCompany *)company;-(void)display:(NSInteger)depth;-(void)lineofDuty;@end12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//HCDConcreteCompany.h@interface HCDConcreteCompany : HCDCompany@end//HCDConcreteCompany.m@interface HCDConcreteCompany ()@property (nonatomic, strong) NSMutableArray *childList;@end@implementation HCDConcreteCompany- (instancetype)initWithName:(NSString *)name&#123; self = [super initWithName:name]; if (self) &#123; _childList = [NSMutableArray array]; &#125; return self;&#125;- (void)add:(HCDCompany *)company&#123; [self.childList addObject:company];&#125;- (void)remove:(HCDCompany *)company&#123; [self.childList removeObject:company];&#125;- (void)display:(NSInteger)depth &#123; NSString *seperate = @""; for (NSInteger i = 0; i &lt; depth; i++) &#123; seperate = [seperate stringByAppendingString:@"-"]; &#125; NSLog(@"%@%@的子公司",seperate,self.name); for (HCDCompany * company in self.childList) &#123; [company display:depth + 2]; &#125;&#125;- (void)lineofDuty&#123; NSLog(@"%@的子公司的职责",self.name); for (HCDCompany * company in self.childList) &#123; [company lineofDuty]; &#125;&#125;@end1234567891011121314151617181920212223242526272829//HCDHRDepartment.h@interface HCDHRDepartment : HCDCompany @end//HCDHRDepartment.m@implementation HCDHRDepartment-(void)add:(HCDCompany *)company&#123; &#125;- (void)display:(NSInteger)depth &#123; NSString *seperate = @""; for (NSInteger i = 0; i &lt; depth; i++) &#123; seperate = [seperate stringByAppendingString:@"-"]; &#125; NSLog(@"%@%@的HR部门",seperate,self.name);&#125;-(void)remove:(HCDCompany *)company&#123;&#125;-(void)lineofDuty&#123; NSLog(@"%@,培训员工",self.name);&#125;@end1234567891011121314151617181920212223242526272829//HCDFinanceDepartment.h@interface HCDFinanceDepartment : HCDCompany@end//HCDFinanceDepartment.m@implementation HCDFinanceDepartment-(void)add:(HCDCompany *)company&#123; &#125;-(void)remove:(HCDCompany *)company&#123; &#125;- (void)display:(NSInteger)depth &#123; NSString *seperate = @""; for (NSInteger i = 0; i &lt; depth; i++) &#123; seperate = [seperate stringByAppendingString:@"-"]; &#125; NSLog(@"%@%@的财务部门",seperate,self.name);&#125;-(void)lineofDuty&#123; NSLog(@"%@,给员工发钱",self.name);&#125;@end适配器模式模式动机适配器提供客户类需要的接口，适配器的实现就是把客户类的请求转化为对适配者的相应接口的调用。也就是说：当客户类调用适配器的方法时，在适配器类的内部将调用适配者类的方法，而这个过程对客户类是透明的，客户类并不直接访问适配者类。因此，适配器可以使由于接口不兼容而不能交互的类可以一起工作。这就是适配器模式的模式动机。模式定义适配器模式：将一个接口转换成客户希望的另一个接口，适配器模式使接口不兼容的那些类可以一起工作，其别名为包装器。适配器模式既可以作为类结构型模式，也可以作为对象结构型模式。模式结构适配器模式包含如下角色：HCDPlayer：目标抽象类HCDTranslator：适配器类HCDForeignCenter：适配者类时序图源码123456789//调用方式 HCDPlayer *forward = [[HCDForwards alloc] initWithName:@"maidi"]; [forward attack]; [forward defense]; HCDForeignCenter *foreignCenter = [[HCDForeignCenter alloc] initWithName:@"姚明"]; HCDPlayer *translator = [[HCDTranslator alloc] initWithForeigncenter:foreignCenter]; [translator attack]; [translator defense];12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152//HCDPlayer.h@interface HCDPlayer : NSObject@property (nonatomic,copy) NSString *name;-(void)attack;-(void)defense;-(instancetype)initWithName:(NSString *)name;@end//HCDForwards.m@implementation HCDForwards-(void)attack&#123; NSLog(@"前锋%@进攻",self.name);&#125;-(void)defense&#123; NSLog(@"前锋%@防守",self.name);&#125;@end//HCDTranslator.m@interface HCDTranslator ()@property(nonatomic, strong) HCDForeignCenter *foreigncenter;@end@implementation HCDTranslator-(instancetype)initWithForeigncenter:(HCDForeignCenter *)foreigncenter &#123; self = [super init]; if (self) &#123; _foreigncenter = foreigncenter; &#125; return self;&#125; -(void)defense&#123; [self.foreigncenter foreignDefent];&#125;-(void)attack&#123; [self.foreigncenter foreignAttact];&#125;@end1234567891011121314151617181920//HCDForeignCenter.m@implementation HCDForeignCenter- (instancetype)initWithName:(NSString *)name&#123; self = [super init]; if (self) &#123; _name = name; &#125; return self;&#125;- (void)foreignAttact&#123; NSLog(@"外籍中锋%@进攻",self.name);&#125;- (void)foreignDefent&#123; NSLog(@"外籍中锋%@防守",self.name);&#125;@end桥接模式模式动机如果需要开发一个跨平台视频播放器，可以在不同操作系统平台（如Windows、Linux、Unix等）上播放多种格式的视频文件，常见的视频格式包括MPEG、RMVB、AVI、WMV等。现使用桥接模式设计该播放器。此时至少有如下两种设计方案：第一种设计方案是为每一种操作系统都提供一套支持各种视频格式的版本；第二种设计方案是根据实际需要对操作系统和支持的视频格式进行组合。对于有两个变化维度（即两个变化的原因）的系统，采用方案二来进行设计系统中类的个数更少，且系统扩展更为方便。设计方案二即是桥接模式的应用。桥接模式将继承关系转换为关联关系，从而降低了类与类之间的耦合，减少了代码编写量。尽量使用组合，而不要使用继承。模式定义桥接模式：将抽象部分与它的实现部分分离，使它们都可以独立地变化。它是一种对象结构型模式。模式结构桥接模式包含如下角色：Abstraction：抽象类RefinedAbstraction：扩充抽象类Implementor：实现类接口ConcreteImplementor：具体实现类时序图源码略装饰模式模式动机一般有两种方式可以实现给一个类或对象增加行为：继承机制，使用继承机制是给现有类添加功能的一种有效途径，通过继承一个现有类可以使得子类在拥有自身方法的同时还拥有父类的方法。但是这种方法是静态的，用户不能控制增加行为的方式和时机；关联机制，即将一个类的对象嵌入另一个对象中，由另一个对象来决定是否调用嵌入对象的行为以便扩展自己的行为，我们称这个嵌入的对象为装饰器(Decorator)。装饰模式以对客户透明的方式动态地给一个对象附加上更多的责任。装饰模式可以在不需要创造更多子类的情况下，将对象的功能加以扩展。这就是装饰模式的模式动机。模式定义装饰模式(Decorator Pattern) ：动态地给一个对象增加一些额外的职责，就增加对象功能来说，装饰模式比生成子类实现更为灵活。它是一种对象结构型模式。模式结构装饰模式包含如下角色：Component: 抽象构件ConcreteComponent: 具体构件Decorator: 抽象装饰类ConcreteDecorator: 具体装饰类时序图源码12345678910111213141516171819202122//使用示例 LTPerson *xc = [[LTPerson alloc] initWithName:@"小菜"]; NSLog(@"\n第一种装扮"); LTSneakers *sneaker = [[LTSneakers alloc] init]; LTBigTrouser *bigTrouser = [[LTBigTrouser alloc] init]; LTTshirts *tshirts = [[LTTshirts alloc] init]; [sneaker decorate:xc]; [bigTrouser decorate:sneaker]; [tshirts decorate:bigTrouser]; [tshirts show]; NSLog(@"\n第二种装扮"); LTLeatherShoes *leatherShoes = [[LTLeatherShoes alloc] init]; LTTie *tie = [[LTTie alloc] init]; LTSuit *suit = [[LTSuit alloc] init]; [leatherShoes decorate:xc]; [tie decorate:leatherShoes]; [suit decorate:tie]; [suit show];12345678910111213141516171819202122232425262728293031//LTPerson.h@interface LTPerson : NSObject- (instancetype)initWithName:(NSString *)name;- (void)show;@end//LTPerson.m@interface LTPerson ()@property (nonatomic, copy) NSString *name;@end@implementation LTPerson- (instancetype)initWithName:(NSString *)name &#123; self = [super init]; if (self) &#123; _name = name; &#125; return self;&#125;- (void)show &#123; NSLog(@"装扮的%@",self.name);&#125;@end123456789101112131415161718192021222324252627282930//LTFinery.h@interface LTFinery : LTPerson- (void)decorate:(LTPerson *)person;@end@interface LTTshirts : LTFinery@end@interface LTBigTrouser : LTFinery@end@interface LTSneakers : LTFinery@end@interface LTLeatherShoes : LTFinery@end@interface LTTie : LTFinery@end@interface LTSuit : LTFinery@end1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374//LTFinery.m@interface LTFinery ()@property (nonatomic, strong) LTPerson *person;@end@implementation LTFinery- (void)decorate:(LTPerson *)person &#123; self.person = person;&#125;- (void)show &#123; if(self.person) &#123; [self.person show]; &#125;&#125;@end@implementation LTTshirts- (void)show &#123; NSLog(@"大T恤"); [super show];&#125;@end@implementation LTBigTrouser- (void)show &#123; NSLog(@"垮裤"); [super show];&#125;@end@implementation LTSneakers- (void)show &#123; NSLog(@"破球鞋"); [super show];&#125;@end@implementation LTLeatherShoes- (void)show &#123; NSLog(@"皮鞋"); [super show];&#125;@end@implementation LTTie- (void)show &#123; NSLog(@"领带"); [super show];&#125;@end@implementation LTSuit- (void)show &#123; NSLog(@"西装"); [super show];&#125;@end外观模式模式动机为子系统中的一组接口提供一个一致的界面，此模式定义了一个高层的接口，这个接口使得这一子系统更加容易使用。模式定义外观模式(Facade Pattern)：外部与一个子系统的通信必须通过一个统一的外观对象进行，为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。它是一种对象结构型模式。模式结构外观模式包含如下角色：Facade: 外观角色SubSystem:子系统角色时序图源码1234//使用示例 HCDFound *found = [[HCDFound alloc]init]; [found buyFund]; [found sellFund];1234//HCDstock.h@interface HCDstock : NSObject&lt;HCDStockProtocol&gt;@end12345678910111213141516171819202122232425262728293031@interface HCDFound()@property (nonatomic, strong) HCDstock1 *stock1;@property (nonatomic, strong) HCDstock2 *stock2;@property (nonatomic, strong) HCDstock3 *stock3;@end@implementation HCDFound-(instancetype)init&#123; self = [super init]; if (self) &#123; _stock1 = [[HCDstock1 alloc]init]; _stock2 = [[HCDstock2 alloc]init]; _stock3 = [[HCDstock3 alloc]init]; &#125; return self;&#125;-(void)buyFund&#123; [self.stock1 buy]; [self.stock2 buy]; [self.stock3 buy];&#125;-(void)sellFund&#123; [self.stock1 sell]; [self.stock2 sell]; [self.stock3 sell];&#125;享元模式模式动机面向对象技术可以很好地解决一些灵活性或可扩展性问题，但在很多情况下需要在系统中增加类和对象的个数。当对象数量太多时，将导致运行代价过高，带来性能下降等问题。享元模式正是为解决这一类问题而诞生的。享元模式通过共享技术实现相同或相似对象的重用。在享元模式中可以共享的相同内容称为内部状态(IntrinsicState)，而那些需要外部环境来设置的不能共享的内容称为外部状态(Extrinsic State)，由于区分了内部状态和外部状态，因此可以通过设置不同的外部状态使得相同的对象可以具有一些不同的特征，而相同的内部状态是可以共享的。在享元模式中通常会出现工厂模式，需要创建一个享元工厂来负责维护一个享元池(Flyweight Pool)用于存储具有相同内部状态的享元对象。在享元模式中共享的是享元对象的内部状态，外部状态需要通过环境来设置。在实际使用中，能够共享的内部状态是有限的，因此享元对象一般都设计为较小的对象，它所包含的内部状态较少，这种对象也称为细粒度对象。享元模式的目的就是使用共享技术来实现大量细粒度对象的复用。模式定义享元模式(Flyweight Pattern)：运用共享技术有效地支持大量细粒度对象的复用。系统只使用少量的对象，而这些对象都很相似，状态变化很小，可以实现对象的多次复用。由于享元模式要求能够共享的对象必须是细粒度对象，因此它又称为轻量级模式，它是一种对象结构型模式。模式结构享元模式包含如下角色：Flyweight: 抽象享元类ConcreteFlyweight: 具体享元类UnsharedConcreteFlyweight: 非共享具体享元类FlyweightFactory: 享元工厂类时序图源码12345678910111213141516//使用示例HCDWebSiteFactory *facoty = [[HCDWebSiteFactory alloc]init];HCDWebSiteType fx = [facoty getWebSiteCategory:@"产品展示"];HCDUser *user = [[HCDUser alloc]init];user.name = @"小菜";[fx use:user];HCDWebSiteType fy = [facoty getWebSiteCategory:@"产品展示"];HCDUser *user1 = [[HCDUser alloc]init];user1.name = @"大鸟";[fy use:user1];HCDWebSiteType fz = [facoty getWebSiteCategory:@"博客"];HCDUser *user2 = [[HCDUser alloc]init];user2.name = @"咪咪";[fz use:user2];12345678910//HCDWebSiteFactory.h@interface HCDWebSiteFactory : NSObject@property(nonatomic,strong) NSDictionary *flyweights;-(id&lt;HCDWebSite&gt; )getWebSiteCategory:(NSString *)webkey;-(NSInteger)getWebSiteCount;@end123456789101112131415161718192021222324252627282930313233343536//HCDWebSiteFactory.m@implementation HCDWebSiteFactory-(instancetype)init&#123; self = [super init]; if (self) &#123; _flyweights = [NSDictionary dictionary]; &#125; return self;&#125;-(id&lt;HCDWebSite&gt; )getWebSiteCategory:(NSString *)webkey&#123; __block id&lt;HCDWebSite&gt; webset = nil; [self.flyweights enumerateKeysAndObjectsUsingBlock:^(id key, id obj, BOOL *stop) &#123; if (webkey == key) &#123; webset = obj; *stop = YES; &#125; &#125;]; if (webset == nil) &#123; HCDConcreteWebSite *concreteset = [[HCDConcreteWebSite alloc] init]; concreteset.webName = webkey; webset = concreteset; NSMutableDictionary *mutabledic = [NSMutableDictionary dictionaryWithDictionary:self.flyweights]; [mutabledic setObject:webset forKey:webkey]; self.flyweights = [NSDictionary dictionaryWithDictionary:mutabledic]; &#125; return webset;&#125;-(NSInteger)getWebSiteCount&#123; return self.flyweights.count;&#125;@end123456789101112131415//HCDConcreteWebSite.h@interface HCDConcreteWebSite : NSObject&lt;HCDWebSite&gt;@property(nonatomic,strong)NSString *webName;@end//HCDConcreteWebSite.m@implementation HCDConcreteWebSite-(void)use:(HCDUser *)user&#123; NSLog(@"网站分类:%@,用户:%@",self.webName,user.name);&#125;@end代理模式模式动机在某些情况下，一个客户不想或者不能直接引用一个对象，此时可以通过一个称之为“代理”的第三者来实现间接引用。代理对象可以在客户端和目标对象之间起到中介的作用，并且可以通过代理对象去掉客户不能看到的内容和服务或者添加客户需要的额外服务。模式定义在某些情况下，一个客户不想或者不能直接引用一个对 象，此时可以通过一个称之为“代理”的第三者来实现 间接引用。代理对象可以在客户端和目标对象之间起到 中介的作用，并且可以通过代理对象去掉客户不能看到 的内容和服务或者添加客户需要的额外服务。模式结构代理模式包含如下角色：Subject: 抽象主题角色Proxy: 代理主题角色RealSubject: 真实主题角色时序图源码1234567//使用示例 HCDschoolGirl *girl = [[HCDschoolGirl alloc] init]; girl.name = @"哈哈哈哈哈"; HCDproxy *proxy = [[HCDproxy alloc] initWithSchoolGirl:girl]; [proxy giveFlowers]; [proxy giveDolls]; [proxy giveChocolate];123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475//HCDschoolGirl.h@interface HCDschoolGirl : NSObject@property(nonatomic,strong)NSString *name;@end//HCDgiveGift.h@protocol HCDgiveGift &lt;NSObject&gt;/// 送洋娃娃- (void)giveDolls;/// 送鲜花- (void)giveFlowers;/// 送巧克力- (void)giveChocolate;@end//HCDpursuit.m@interface HCDpursuit ()@property(nonatomic,strong)HCDschoolGirl *schoolGirl;@end@implementation HCDpursuit-(instancetype)initWithSchoolGirl:(HCDschoolGirl *)schoolGirl&#123; self = [super init]; if (self) &#123; _schoolGirl = schoolGirl; &#125; return self;&#125;-(void)giveChocolate&#123; NSLog(@"送你巧克力%@",self.schoolGirl.name);&#125;-(void)giveDolls&#123; NSLog(@"送你洋娃娃%@",self.schoolGirl.name);&#125;-(void)giveFlowers&#123; NSLog(@"送你玫瑰花%@",self.schoolGirl.name);&#125;@end//HCDproxy.m@interface HCDproxy ()@property (strong, nonatomic) HCDpursuit *pursuit;@end@implementation HCDproxy- (instancetype)initWithSchoolGirl:(HCDschoolGirl *)schoolGirl &#123; self = [super init]; if (self) &#123; self.pursuit = [[HCDpursuit alloc] initWithSchoolGirl:schoolGirl]; &#125; return self;&#125;- (void)giveDolls &#123; [self.pursuit giveDolls];&#125;- (void)giveFlowers &#123; [self.pursuit giveFlowers];&#125;- (void)giveChocolate &#123; [self.pursuit giveChocolate];&#125;@end行为型模式迭代器模式模式动机针对不同的需要，可能还要以不同的方式遍历整个聚合对象，但是我们并不希望在聚合对象的抽象层接口中充斥着各种不同遍历的操作。怎样遍历一个聚合对象，又不需要了解聚合对象的内部结构，还能够提供多种不同的遍历方式，这就是迭代器模式的模式动机。模式定义提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露该对象的内部表示。模式结构模板方法模式包含如下角色：Aggregate: 聚集抽象类ConcreteAggregate: 具体聚集类Iterator: 迭代抽象类ConcreteIterator: 具体迭代器类时序图略源码略命令模式模式动机在软件设计中，我们经常需要向某些对象发送请求，但是并不知道请求的接收者是谁，也不知道被请求的操作是哪个，我们只需在程序运行时指定具体的请求接收者即可，此时，可以使用命令模式来进行设计，使得请求发送者与请求接收者消除彼此之间的耦合，让对象之间的调用关系更加灵活。命令模式可以对发送者和接收者完全解耦，发送者与接收者之间没有直接引用关系，发送请求的对象只需要知道如何发送请求，而不必知道如何完成请求。这就是命令模式的模式动机。模式定义命令模式(Command Pattern)：将一个请求封装为一个对象，从而使我们可用不同的请求对客户进行参数化；对请求排队或者记录请求日志，以及支持可撤销的操作。命令模式是一种对象行为型模式，其别名为动作(Action)模式或事务(Transaction)模式。模式结构命令模式包含如下角色：Command: 抽象命令类ConcreteCommand: 具体命令类Invoker: 调用者Receiver: 接收者Client:客户类时序图源码12345678910111213141516171819202122//使用示例 //waiter用于接收各种类型的order。waiter是请求接收者。 //接收不同customer产生的不同order，并且都存入waiter这个接受者中,type表示不同类型的order。 HCDWaiter *waiter = [[HCDWaiter alloc]init]; //顾客一 HCDCustomr *customer = [[HCDCustomr alloc]init]; HCDOrder *customerOrder1 = [customer pushOrderWithString:@"顾客一要十串羊肉" type:orderTypeMutton]; HCDOrder *customerOrder2 = [customer pushOrderWithString:@"顾客一要十串鸭肉" type:orderTypeDuck]; [waiter addOrder:customerOrder1]; [waiter addOrder:customerOrder2]; //顾客二 HCDCustomr *customer1 = [[HCDCustomr alloc]init]; HCDOrder *customer1Order1 = [customer1 pushOrderWithString:@"顾客二要二十串鸡肉" type:orderTypeChicken]; HCDOrder *customer1Order2 = [customer1 pushOrderWithString:@"顾客二要二十串鸭肉" type:orderTypeDuck]; [waiter addOrder:customer1Order1]; [waiter addOrder:customer1Order2]; [waiter deleteOrder:customer1Order2]; //waiter发送order，背后有一个HCDWorker这个单列作为行为实现者来处理具体的order。命令接收完毕，开始发送命令。 [waiter notifyOrder];12345678910111213141516171819//HCDCustomr.m@implementation HCDCustomr-(HCDOrder *)pushOrderWithString:(NSString *)string type:(orderType)type&#123; HCDOrder *order = nil; switch (type) &#123; case orderTypeMutton: order = [[HCDMuttonOrder alloc]initWithOrderString:string]; break; case orderTypeChicken: order = [[HCDChickenOrder alloc]initWithOrderString:string]; break; case orderTypeDuck: order = [[HCDDuckOrder alloc]initWithOrderString:string]; break; &#125; return order;&#125;@end12345678910111213141516171819202122232425262728//HCDWaiter.m@implementation HCDWaiter-(instancetype)init&#123; self = [super init]; if (self) &#123; _orderList = [NSMutableArray array]; &#125; return self;&#125;-(void)addOrder:(HCDOrder *)order&#123; NSLog(@"添加Order"); [self.orderList addObject:order];&#125;-(void)deleteOrder:(HCDOrder *)order&#123; NSLog(@"取消Order"); [self.orderList removeObject:order];&#125;/* 命令接收完毕，开始执行命令 */-(void)notifyOrder&#123; NSLog(@"====开始执行Order==="); for (HCDOrder *order in self.orderList) &#123; [order executeOrder]; &#125;&#125;@end123456789101112131415161718192021222324252627282930313233343536373839//HCDOrder.h@interface HCDOrder : NSObject@property(nonatomic,copy)NSString *orderString;-(instancetype)initWithOrderString:(NSString *)orderString;//执行命令-(void)executeOrder;@end//HCDMuttonOrder.m@implementation HCDMuttonOrder-(void)executeOrder&#123; NSLog(@"烤羊"); [[HCDWorker sharedWorker] doMuttonWork:self.orderString];&#125;@end//HCDChickenOrder.m@implementation HCDChickenOrder-(void)executeOrder&#123; NSLog(@"烤鸡"); [[HCDWorker sharedWorker] doChickenWork:self.orderString];&#125;@end//HCDDuckOrder.m@implementation HCDDuckOrder-(void)executeOrder&#123; NSLog(@"烤鸭"); [[HCDWorker sharedWorker] doChickenWork:self.orderString];&#125;@end123456789101112//HCDWorker.h@interface HCDWorker : NSObject+(instancetype)sharedWorker;-(void)doMuttonWork:(NSString *)work;-(void)doChickenWork:(NSString *)work;-(void)doDuckWork:(NSString *)work;@end中介者模式模式动机在用户与用户直接聊天的设计方案中，用户对象之间存在很强的关联性，将导致系统出现如下问题：系统结构复杂：对象之间存在大量的相互关联和调用，若有一个对象发生变化，则需要跟踪和该对象关联的其他所有对象，并进行适当处理。对象可重用性差：由于一个对象和其他对象具有很强的关联，若没有其他对象的支持，一个对象很难被另一个系统或模块重用，这些对象表现出来更像一个不可分割的整体，职责较为混乱。系统扩展性低：增加一个新的对象需要在原有相关对象上增加引用，增加新的引用关系也需要调整原有对象，系统耦合度很高，对象操作很不灵活，扩展性差。在面向对象的软件设计与开发过程中，根据“单一职责原则”，我们应该尽量将对象细化，使其只负责或呈现单一的职责。对于一个模块，可能由很多对象构成，而且这些对象之间可能存在相互的引用，为了减少对象两两之间复杂的引用关系，使之成为一个松耦合的系统，我们需要使用中介者模式，这就是中介者模式的模式动机。模式定义中介者模式(Mediator Pattern)定义：用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。它是一种对象行为型模式。模式结构中介者模式包含如下角色：Mediator: 抽象中介者ConcreteMediator: 具体中介者Colleague: 抽象同事类ConcreteColleague: 具体同事类时序图源码12345678910111213//使用示例ConcreteMediator *mediator = [[ConcreteMediator alloc] init];//初始化并且让两个同事有相同的中介者对象ConcreteColleague1 *c1 = [[ConcreteColleague1 alloc] initWithMediator:mediator];ConcreteColleague2 *c2 = [[ConcreteColleague2 alloc] initWithMediator:mediator];//给中介者对象绑定两个要交互的同事对象mediator.colleague1 = c1;mediator.colleague2 = c2;[c1 send:@"吃过饭了吗？"];[c2 send:@"没有呢，你打算请客？"];12345678910//Mediator.h@class Colleague;@interface Mediator : NSObject@property (nonatomic, strong) Colleague *colleague1;@property (nonatomic, strong) Colleague *colleague2;-(void)send:(NSString *)message colleague:(Colleague *)colleague;@end123456789101112//ConcreteMediator.m@implementation ConcreteMediator-(void)send:(NSString *)message colleague:(Colleague *)colleague&#123; if (colleague == self.colleague1) &#123; [self.colleague2 notify:message]; &#125;else&#123; [self.colleague1 notify:message]; &#125;&#125;@end12345678910111213//Colleague.h@class Mediator;@interface Colleague : NSObject@property(nonatomic, strong) Mediator *mediator;-(instancetype)initWithMediator:(Mediator *)mediator;-(void)notify:(NSString *)message;-(void)send:(NSString *)message;@end123456789101112131415161718192021//ConcreteColleague1.m@implementation ConcreteColleague1-(instancetype)initWithMediator:(Mediator *)mediator&#123; self = [super init]; if (self) &#123; self.mediator = mediator; &#125; return self;&#125;-(void)send:(NSString *)message&#123; NSLog(@"同事1发送了信息"); [self.mediator send:message colleague:self];&#125;-(void)notify:(NSString *)message&#123; NSLog(@"%@%@",@"同事1得到消息:", message);&#125;@end123456789101112131415161718192021//ConcreteColleague2.m@implementation ConcreteColleague2-(instancetype)initWithMediator:(Mediator *)mediator&#123; self = [super init]; if (self) &#123; self.mediator = mediator; &#125; return self;&#125;-(void)send:(NSString *)message&#123; NSLog(@"同事2发送了信息"); [self.mediator send:message colleague:self];&#125;-(void)notify:(NSString *)message&#123; NSLog(@"%@%@",@"同事2得到消息", message);&#125;@end观察者模式模式动机建立一种对象与对象之间的依赖关系，一个对象发生改变时将自动通知其他对象，其他对象将相应做出反应。在此，发生改变的对象称为观察目标，而被通知的对象称为观察者，一个观察目标可以对应多个观察者，而且这些观察者之间没有相互联系，可以根据需要增加和删除观察者，使得系统更易于扩展，这就是观察者模式的模式动机。模式定义观察者模式(Observer Pattern)：定义对象间的一种一对多依赖关系，使得每当一个对象状态发生改变时，其相关依赖对象皆得到通知并被自动更新。观察者模式是一种对象行为型模式。模式结构观察者模式包含如下角色：Subject: 目标ConcreteSubject: 具体目标Observer: 观察者ConcreteObserver: 具体观察者时序图源码123456789101112131415161718192021222324252627282930313233343536373839//使用示例- (void)viewDidLoad &#123; [super viewDidLoad]; HCDServiceCenter *serviceCenter = [[HCDServiceCenter alloc] init]; [serviceCenter addDelegate:self.nbaobserver]; [serviceCenter addDelegate:self.stockobserver]; [serviceCenter addDelegate:self.gameObserver]; NSLog(@"秘书通知：老板回来了，大家赶紧撤"); [serviceCenter notifyServiceDelegate:@selector(update) perform:^(id responder) &#123; [responder update]; &#125;];&#125;#pragma mark - getter &amp; setter-(HCDNBAObserver *)nbaobserver &#123; if (!_nbaobserver) &#123; _nbaobserver = [[HCDNBAObserver alloc] init]; &#125; return _nbaobserver;&#125;-(HCDStockObserver *)stockobserver &#123; if (!_stockobserver) &#123; _stockobserver = [[HCDStockObserver alloc] init]; &#125; return _stockobserver;&#125;-(HCDGameObserver *)gameObserver &#123; if (!_gameObserver) &#123; _gameObserver = [[HCDGameObserver alloc] init]; &#125; return _gameObserver;&#125;123456789101112131415//HCDServiceCenter.h@interface HCDServiceCenter : NSObject@property(nonatomic, strong, readonly) NSHashTable *responders;- (instancetype)initWithNotifyQueue:(dispatch_queue_t)notifyQueue;- (void)addDelegate:(id)delegate;- (void)removeDelegate:(id)delegate;- (void)notifyServiceDelegate:(SEL)aSelector perform:(void (^)(id responder))perform;@end1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162//HCDServiceCenter.m#define LOCK(...) dispatch_semaphore_wait(_lock, DISPATCH_TIME_FOREVER); \__VA_ARGS__; \dispatch_semaphore_signal(_lock);@interface HCDServiceCenter()@property(nonatomic, strong) dispatch_queue_t notifyQueue;@property(nonatomic, strong) NSHashTable *responders;@end@implementation HCDServiceCenter &#123; dispatch_semaphore_t _lock;&#125;- (instancetype)init &#123; self = [super init]; if (self) &#123; self.responders = [NSHashTable weakObjectsHashTable]; self.notifyQueue = dispatch_get_main_queue(); _lock = dispatch_semaphore_create(1); &#125; return self;&#125;- (instancetype)initWithNotifyQueue:(dispatch_queue_t)notifyQueue &#123; self = [super init]; if (self) &#123; self.responders = [NSHashTable weakObjectsHashTable]; self.notifyQueue = notifyQueue; &#125; return self;&#125;- (void)addDelegate:(id)delegate &#123; LOCK([self.responders addObject:delegate]);&#125;- (void)removeDelegate:(id)delegate &#123; LOCK([self.responders removeObject:delegate]); &#125;- (void)notifyServiceDelegate:(SEL)aSelector perform:(void (^)(id responder))perform &#123; dispatch_async(self.notifyQueue, ^&#123; NSArray *responders = self.responders.allObjects; for (id responder in responders) &#123; if ([responder respondsToSelector:aSelector]) &#123; @try &#123; perform(responder); &#125; @catch (NSException *exception) &#123; NSLog(@"catch notifyServiceDelegate exception: %@", exception); &#125; &#125; &#125; &#125;);&#125;@end12345678910111213141516171819202122//HCDObserver.h@protocol HCDObserver &lt;NSObject&gt;@optional- (void)update;@end//HCDStockObserver.h@interface HCDStockObserver : NSObject&lt;HCDObserver&gt;@end//HCDNBAObserver.h@interface HCDNBAObserver : NSObject&lt;HCDObserver&gt;@end//HCDGameObserver.h@interface HCDGameObserver : NSObject&lt;HCDObserver&gt;@end状态模式模式动机在很多情况下，一个对象的行为取决于一个或多个动态变化的属性，这样的属性叫做状态，这样的对象叫做有状态的(stateful)对象，这样的对象状态是从事先定义好的一系列值中取出的。当一个这样的对象与外部事件产生互动时，其内部状态就会改变，从而使得系统的行为也随之发生变化。状态模式主要解决的是当控制一个对象状态转换的条件表达式过于负责时的情况。把状态的判断逻辑转移到表示不同状态的一系列类当中，可以把复杂的判断逻辑简化。模式定义允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类。状态模式是一种对象行为型模式。模式结构状态模式包含如下角色：Context: 环境类State: 抽象状态类ConcreteState: 具体状态类时序图源码12345678910111213141516171819202122232425262728//使用示例HCDWork *work = [[HCDWork alloc]init];work.hour = 9;[work writeProgram];work.hour = 10;[work writeProgram];work.hour = 12;[work writeProgram];work.hour = 13;[work writeProgram];work.hour = 14;[work writeProgram];work.hour = 17;[work writeProgram];work.finished = NO;[work writeProgram];work.hour = 19;[work writeProgram];work.hour = 22;[work writeProgram];123456789101112//HCDWork.h@interface HCDWork : NSObject@property(nonatomic, assign) CGFloat hour;@property(nonatomic, assign) BOOL finished;- (void)writeProgram;- (void)changeState:(HCDState *)state;@end1234567891011121314151617181920212223242526//HCDWork.m@interface HCDWork()@property (nonatomic, strong) HCDState *state;@end@implementation HCDWork- (instancetype)init&#123; self = [super init]; if (self) &#123; self.state = [[HCDForenoonState alloc]init]; &#125; return self;&#125;- (void)writeProgram &#123; [self.state writeProgram:self];&#125;- (void)changeState:(HCDState *)state &#123; self.state = state;&#125;@end12345678//HCDProtocol.h@class HCDWork;@protocol HCDProtocol &lt;NSObject&gt;@optional- (void)writeProgram:(HCDWork *)work;@end1234//HCDState.h@interface HCDState : NSObject&lt;HCDProtocol&gt;@end12345678910111213//HCDForenoonState.m@implementation HCDForenoonState-(void)writeProgram:(HCDWork *)work&#123; if (work.hour &lt; 12) &#123; NSLog(@"当前时间：&#123;%.f&#125;点，上午工作，精神百倍", work.hour); &#125;else&#123; HCDNoonState *noonState = [[HCDNoonState alloc] init]; [work changeState:noonState]; [work writeProgram]; &#125;&#125;@end12345678910111213//HCDNoonState.m@implementation HCDNoonState-(void)writeProgram:(HCDWork *)work&#123; if (work.hour &lt; 13) &#123; NSLog(@"当前时间：&#123;%.f&#125;点，饿了，午饭；犯困，午休", work.hour); &#125; else &#123; HCDAfternoonState *afternoonState = [[HCDAfternoonState alloc] init]; [work changeState:afternoonState]; [work writeProgram]; &#125;&#125;@end12345678910111213//HCDAfternoonState.m@implementation HCDAfternoonState-(void)writeProgram:(HCDWork *)work&#123; if (work.hour &lt; 17) &#123; NSLog(@"当前时间：&#123;%.f&#125;点，下午状态还不错，继续努力", work.hour); &#125; else &#123; HCDEventState *eventState = [[HCDEventState alloc] init]; [work changeState:eventState]; [work writeProgram]; &#125;&#125;@end123456789101112131415161718192021//HCDEventState.m@implementation HCDEventState-(void)writeProgram:(HCDWork *)work&#123; if (work.finished) &#123; HCDRestState *restState = [[HCDRestState alloc] init]; [work changeState:restState]; [work writeProgram]; &#125; else &#123; if (work.hour &lt; 21) &#123; NSLog(@"当前时间：&#123;%.f&#125;点，加班哦，疲累之极", work.hour); &#125; else &#123; HCDSleepState *sleepState = [[HCDSleepState alloc] init]; [work changeState:sleepState]; [work writeProgram]; &#125; &#125;&#125;@end1234567//HCDSleepState.m@implementation HCDSleepState- (void)writeProgram:(HCDWork *)work &#123; NSLog(@"当前时间：&#123;%.f&#125;点，不行了，睡着了", work.hour);&#125;@end1234567//HCDRestState.m@implementation HCDRestState- (void)writeProgram:(HCDWork *)work &#123; NSLog(@"当前时间：&#123;%.f&#125;点，下班回家了", work.hour);&#125;@end策略模式模式动机完成一项任务，往往可以有多种不同的方式，每一种方式称为一个策略，我们可以根据环境或者条件的不同选择不同的策略来完成该项任务。在软件开发中也常常遇到类似的情况，实现某一个功能有多个途径，此时可以使用一种设计模式来使得系统可以灵活地选择解决途径，也能够方便地增加新的解决途径。为了解决这些问题，可以定义一些独立的类来封装不同的算法，每一个类封装一个具体的算法，在这里，每一个封装算法的类我们都可以称之为策略(Strategy)，为了保证这些策略的一致性，一般会用一个抽象的策略类来做算法的定义，而具体每种算法则对应于一个具体策略类。模式定义定义了算法家族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化，不会影响到使用算法的客户。模式结构策略模式包含如下角色：Context: 环境类Strategy: 抽象策略类ConcreteStrategy: 具体策略类时序图源码123456789//使用示例HCDCashContext *context = [[HCDCashContext alloc] initWithCashType:HCDCashTypeNormal];NSLog(@"结果是%f",[context getResult:100]);HCDCashContext *contextReturn = [[HCDCashContext alloc] initWithCashType:HCDCashTypeReturn];NSLog(@"结果是%f",[contextReturn getResult:100]);HCDCashContext *contextRobate = [[HCDCashContext alloc] initWithCashType:HCDCashTypeRobate];NSLog(@"结果是%f",[contextRobate getResult:100]);1234567891011121314//HCDCashContext.htypedef NS_ENUM(NSInteger, HCDCashType)&#123; HCDCashTypeNormal = 0, HCDCashTypeRobate, HCDCashTypeReturn&#125;;@interface HCDCashContext : NSObject -(instancetype)initWithCashType:(HCDCashType)type;-(CGFloat)getResult:(CGFloat)money;@end123456789101112131415161718192021222324252627282930313233343536373839//HCDCashContext.m@interface HCDCashContext()@property (nonatomic, strong) id&lt;HCDCashProtocol&gt; cash;@end@implementation HCDCashContext -(instancetype)initWithCashType:(HCDCashType)type&#123; self = [super init]; if (self) &#123; [self cofigureWithCashType:type]; &#125; return self;&#125;- (void)cofigureWithCashType:(HCDCashType)type &#123; switch (type) &#123; case HCDCashTypeNormal: &#123; self.cash = [[HCDCashNormal alloc] init]; &#125; break; case HCDCashTypeRobate: &#123; self.cash = [[HCDCashRobate alloc] initWithMoneyRebate:0.8]; &#125; break; case HCDCashTypeReturn: &#123; self.cash = [[HCDCaseReturn alloc] initWithMoneyReturn:5]; &#125; break; &#125;&#125;- (CGFloat)getResult:(CGFloat)money &#123; return [self.cash acceptCash:money];&#125;@end123456//HCDCashProtocol.h@protocol HCDCashProtocol &lt;NSObject&gt;- (CGFloat)acceptCash:(CGFloat)cash;@end123456789101112131415161718192021222324252627282930313233//HCDCaseReturn.h@interface HCDCaseReturn : NSObject&lt;HCDCashProtocol&gt;-(instancetype)initWithMoneyReturn:(CGFloat)moneyReturn;@end//HCDCaseReturn.m@interface HCDCaseReturn ()@property (nonatomic, assign)CGFloat moneyReturn;@end@implementation HCDCaseReturn#pragma mark - life cycle-(instancetype)initWithMoneyReturn:(CGFloat)moneyReturn&#123; self = [super init]; if (self) &#123; _moneyReturn = moneyReturn; &#125; return self;&#125;#pragma mark - HCDCashProtocol-(CGFloat)acceptCash:(CGFloat)cash&#123; return cash - self.moneyReturn;&#125;@end12345678//HCDCashNormal.m@implementation HCDCashNormal -(CGFloat)acceptCash:(CGFloat)cash&#123; return cash;&#125;@end1234567891011121314151617181920212223242526272829//HCDCashRobate.h@interface HCDCashRobate : NSObject&lt;HCDCashProtocol&gt;-(instancetype)initWithMoneyRebate:(CGFloat)moneyRebate;@end//HCDCashRobate.m@interface HCDCashRobate ()@property (nonatomic, assign) CGFloat moneyRebate;@end@implementation HCDCashRobate-(instancetype)initWithMoneyRebate:(CGFloat)moneyRebate&#123; self = [super init]; if (self) &#123; _moneyRebate = moneyRebate; &#125; return self;&#125;-(CGFloat)acceptCash:(CGFloat)cash&#123; return self.moneyRebate * cash;&#125;@end模板方法模式模式动机模板方法模式是基于继承的代码复用基本技术，模板方法模式的结构和用法也是面向对象设计的核心之一。在模板方法模式中，可以将相同的代码放在父类中，而将不同的方法实现放在不同的子类中。模式定义定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。模式结构模板方法模式包含如下角色：AbstractClass: 抽象类ConcreteClass: 具体子类时序图略源码12345678//使用示例HCDtextPaper *paperA = [[HCDtextPaperA alloc]init];[paperA testQuestion1];[paperA testQuestion2];HCDtextPaper *paperB = [[HCDtextPaperB alloc]init];[paperB testQuestion1];[paperB testQuestion2];12345678910111213141516171819202122//HCDtextPaper.h@interface HCDtextPaper : NSObject- (void)testQuestion1;- (void)testQuestion2;/** 子类需要重写这个方法 @return 结果 */- (NSString *)answer1;/** 子类需要重写这个方法 @return 结果 */- (NSString *)answer2;@end12345678910111213141516171819202122//HCDtextPaper.m@implementation HCDtextPaper-(void)testQuestion1 &#123; NSLog(@"问题：杨过得到，后来给了郭靖，炼成倚天剑、屠龙刀的玄铁可能是[ ]：a.球磨铸铁 b.马口铁 c.高速合金钢 d.碳素纤维"); NSLog(@"答案：%@", [self answer1]);&#125;-(NSString *)answer1 &#123; return @"";&#125;-(void)testQuestion2 &#123; NSLog(@"问题：杨过、程英、陆无双铲除了情花，造成[ ]：a.使这种植物不再害人 b.使一种珍稀物种灭绝 c.破坏了那个生物圈的生态平衡 d.造成该地区沙漠化"); NSLog(@"答案：%@", [self answer2]);&#125;-(NSString *)answer2&#123; return @"";&#125;@end123456789101112//HCDtextPaperA.m@implementation HCDtextPaperA-(NSString *)answer1&#123; return @"b";&#125;-(NSString *)answer2&#123; return @"c";&#125;@end123456789101112//HCDtextPaperB.m@implementation HCDtextPaperB-(NSString *)answer1&#123; return @"a";&#125;-(NSString *)answer2&#123; return @"d";&#125;@end职责链模式模式动机很多情况下，在一个软件系统中可以处理某个请求的对象不止一个。例如采购审批子系统，主任、副董事长、董事长和董事会都可以处理采购单，他们可以构成一条处理采购单的链式结构，采购单(可以看作是要处理的信息)沿着这条链进行传递，这条链就称为责任链。责任链可以是一条直线、一个环或者一个树形结构，最常见的职责链是直线型，即沿着一条单向的链来传递请求，如下图所示。链上的每一个对象都是请求处理者，责任链模式可以将请求的处理者组织成一条链，并让请求沿着链传递，由链上的处理者对请求进行相应的处理。在此过程中，客户端实际上无须关心请求的处理细节以及请求的传递，只需将请求发送到链上即可，从而实现请求发送者和请求处理者解耦。模式定义使多个对象都有机会处理请求，从而避免请求的发送者和接受者之间的耦合关系。将这个对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。模式结构职责链模式包含如下角色：Handler: 处理者抽象类ConcreteAggregate: 具体处理者类时序图略源码123456789101112131415161718192021222324252627282930//使用示例HCDCommonManager *jinli = [[HCDCommonManager alloc]initWithName:@"经理"];HCDMajorManager *zongjian = [[HCDMajorManager alloc]initWithName:@"总监"];HCDGenaralManager *zongjinli = [[HCDGenaralManager alloc]initWithName:@"总经理"];jinli.superior = zongjian;zongjian.superior = zongjinli;HCDReuquest *request = [[HCDReuquest alloc] init];request.requestType = @"请假";request.requestContent = @"小菜请假";request.number = 1;[jinli dealRequest:request];HCDReuquest *request1 = [[HCDReuquest alloc] init];request1.requestType = @"请假";request1.requestContent = @"小菜请假";request1.number = 4;[jinli dealRequest:request1];HCDReuquest *request2 = [[HCDReuquest alloc] init];request2.requestType = @"加薪";request2.requestContent = @"小菜请求加薪";request2.number = 500;[jinli dealRequest:request2];HCDReuquest *request4 = [[HCDReuquest alloc] init];request4.requestType = @"加薪";request4.requestContent = @"小菜请求加薪";request4.number = 1000;[jinli dealRequest:request4];12345678910111213//HCDMnager.h@class HCDReuquest;@interface HCDMnager : NSObject@property (nonatomic, copy) NSString *name;@property (nonatomic, strong) HCDMnager *superior;- (instancetype)initWithName:(NSString *)name;- (void)dealRequest:(HCDReuquest *)request;@end12345678910111213141516171819//HCDCommonManager.h@interface HCDCommonManager : HCDMnager@end//HCDCommonManager.m@implementation HCDCommonManager- (void)dealRequest:(HCDReuquest *)request&#123; if ([request.requestType isEqualToString:@"请假"] &amp;&amp; request.number &lt;= 2) &#123; NSLog(@"%@:%@ 数量%ld 被批准",self.name,request.requestType,request.number); &#125;else&#123; if (self.superior) &#123; [self.superior dealRequest:request]; &#125; &#125;&#125;@end123456789101112131415161718//HCDMajorManager.h@interface HCDMajorManager : HCDMnager@end//HCDMajorManager.m@implementation HCDMajorManager-(void)dealRequest:(HCDReuquest *)request&#123; if ([request.requestType isEqualToString:@"请假"] &amp;&amp; request.number &lt;= 5) &#123; NSLog(@"%@:%@ 数量%ld 被批准",self.name,request.requestType,request.number); &#125;else&#123; if (self.superior) &#123; [self.superior dealRequest:request]; &#125; &#125;&#125;@end1234567891011121314151617181920212223//HCDGenaralManager.h@interface HCDGenaralManager : HCDMnager@end//HCDGenaralManager.m@implementation HCDGenaralManager-(void)dealRequest:(HCDReuquest *)request&#123; if ([request.requestType isEqualToString:@"请假"]) &#123; NSLog(@"%@:%@ 数量%ld 被批准",self.name,request.requestType,request.number); &#125; else if ([request.requestType isEqualToString:@"加薪"])&#123; if (request.number &lt;= 500) &#123; NSLog(@"%@:%@ 数量%ld 被批准",self.name,request.requestType,request.number); &#125; else &#123; NSLog(@"%@:%@ 数量%ld 再说吧",self.name,request.requestType,request.number); &#125; &#125; else &#123; &#125;&#125;@end123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687//HCDReuquest.h@interface HCDReuquest : NSObject/** 请求类型 */@property (nonatomic, copy) NSString *requestType;/** 请求内容 */@property (nonatomic, copy) NSString *requestContent;/** 请求的数量 */@property(nonatomic, assign) NSInteger number;@end``` #### 解释器模式##### 模式动机如果在系统中某一特定类型的问题发生的频率很高，此时可以考虑将这些问题的实例表述为一个语言中的句子，因此可以构建一个解释器，该解释器通过解释这些句子来解决这些问题。解释器模式描述了如何构成一个简单的语言解释器，主要应用在使用面向对象语言开发的编译器中。##### 模式定义给定一种语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。##### 模式结构解释器模式模式包含如下角色：- AbstractExpression: 抽象表达式- TerminalExpression: 终结符表达式- NonterminalExpression: 非终结符表达式- Context: 环境类- Client: 客户类![解释器模式类图](/images/design-interpreter-pattern-class.png)##### 时序图略##### 源码略#### 访问者模式##### 模式动机访问者模式的目的是封装一些施加于某种数据结构元素之上的操作，一旦这些操作需要修改的话，接受这个操作的数据结构可以保持不变。为不同类型的元素提供多种访问操作方式，且可以在不修改原有系统的情况下增加新的操作方式，这就是访问者模式的模式动机。##### 模式定义表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。##### 模式结构访问者模式包含如下角色：- Vistor: 抽象访问者。为该对象结构中的ConcreteElement的每一个类声明的一个操作。 - ConcreteVisitor: 具体访问者。实现Visitor申明的每一个操作，每一个操作实现算法的一部分。 - Element: 抽象元素。定义一个Accept操作，它以一个访问者为参数。 - ConcreteElement: 具体元素 。实现Accept操作。 - ObjectStructure: 对象结构。能够枚举它的元素，可以提供一个高层的接口来允许访问者访问它的元素。![访问者模式类图](/images/design-visitor-pattern-class.png)##### 时序图略##### 源码```objc //使用示例 HCDObjectStructure *o = [[HCDObjectStructure alloc]init]; //初始化不同的element对象 HCDConcreteElementA *eA = [HCDConcreteElementA new]; HCDConcreteElementB *eB = [HCDConcreteElementB new]; //加入o对象里面，存在一个数据结构o中。 [o attach:eA]; [o attach:eB]; //初始化不同的visitor对象。 HCDConcreteVisitor1 *v1 = [HCDConcreteVisitor1 new]; HCDConcreteVisitor2 *v2 = [HCDConcreteVisitor2 new]; //eA,eB(男人女人)接收到访问者v1(喜)的不同反应。 [o accept:v1]; NSLog(@"================================"); //eA,eB(男人女人)接收到访问者v2(怒)的不同反应。 [o accept:v2];12345678910111213//HCDObjectStructure.h@class HCDElements;@class HCDVisitors;@interface HCDObjectStructure : NSObject-(void)attach:(HCDElements *)element;-(void)detach:(HCDElements *)element;-(void)accept:(HCDVisitors *)visitor;@end1234567891011121314151617181920212223242526272829303132//HCDObjectStructure.m@interface HCDObjectStructure ()@property (nonatomic, strong) NSMutableArray *elements;@end@implementation HCDObjectStructure-(instancetype)init&#123; self = [super init]; if (self) &#123; _elements = [[NSMutableArray alloc]init]; &#125; return self;&#125;-(void)attach:(HCDElements *)element&#123; [self.elements addObject:element];&#125;-(void)detach:(HCDElements *)element&#123; [self.elements removeObject:element];&#125;-(void)accept:(HCDVisitors *)visitor&#123; for (HCDElements *e in self.elements) &#123; [e accept:visitor]; &#125;&#125;@end1234567891011121314151617181920212223242526272829303132333435363738394041424344//HCDVisitors.h@interface HCDVisitors : NSObject-(void)visitConcreteElementA:(HCDConcreteElementA *)concreteElementA;-(void)visitConcreteElementB:(HCDConcreteElementB *)concreteElementB;@end//HCDConcreteVisitor1.h@interface HCDConcreteVisitor1 : HCDVisitors@end//HCDConcreteVisitor1.m@implementation HCDConcreteVisitor1-(void)visitConcreteElementA:(HCDConcreteElementA *)concreteElementA&#123; NSLog(@"男人接收到喜这个visitor============我要飞");&#125;-(void)visitConcreteElementB:(HCDConcreteElementB *)concreteElementB&#123; NSLog(@"女人接收到喜这个visitor============我要跳");&#125;@end//HCDConcreteVisitor2.h@interface HCDConcreteVisitor2 : HCDVisitors@end//HCDConcreteVisitor2.m@implementation HCDConcreteVisitor2-(void)visitConcreteElementA:(HCDConcreteElementA *)concreteElementA&#123; NSLog(@"男人接收到怒这个visitor============我要叫");&#125;-(void)visitConcreteElementB:(HCDConcreteElementB *)concreteElementB&#123; NSLog(@"女人接收到怒这个visitor============我要苦");&#125;@end1234567//HCDElements.h@class HCDVisitors;@interface HCDElements : NSObject-(void)accept:(HCDVisitors *)visitor;@end123456789101112//HCDConcreteElementA.m@implementation HCDConcreteElementA-(void)operationA&#123; return;&#125;-(void)accept:(HCDVisitors *)visitor&#123; [visitor visitConcreteElementA:self];&#125;@end//HCDConcreteElementB.m @implementation HCDConcreteElementB -(void)operationB{ return; } -(void)accept:(HCDVisitors *)visitor{ [visitor visitConcreteElementB:self]; } @end 小结在实际的项目开发过程中，使用某些特定的设计模式能够很好的解决问题。同时，在维护他人编写的代码时，如果对设计模式特别熟悉，遇到时也比较容易定位问题。源码和demo请点这里参考的文章链接如下Graphic Design Patterns]]></content>
      <categories>
        <category>设计模式 开发</category>
      </categories>
      <tags>
        <tag>设计模式 设计模式六大原则</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用事件响应链处理事件]]></title>
    <url>%2F2018%2F07%2F03%2F%E4%BD%BF%E7%94%A8%E4%BA%8B%E4%BB%B6%E5%93%8D%E5%BA%94%E9%93%BE%E5%A4%84%E7%90%86%E4%BA%8B%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[概述Apps receive and handle events using responder objects. A responder object is any instance of the UIResponder class, and common subclasses include UIView, UIViewController, and UIApplication. Responders receive the raw event data and must either handle the event or forward it to another responder object. When your app receives an event, UIKit automatically directs that event to the most appropriate responder object, known as the first responder.Unhandled events are passed from responder to responder in the active responder chain, which is the dynamic configuration of your app’s responder objects. Figure 1 shows the responders in an app whose interface contains a label, a text field, a button, and two background views. The diagram also shows how events move from one responder to the next, following the responder chain.If the text field does not handle an event, UIKit sends the event to the text field’s parent UIView object, followed by the root view of the window. From the root view, the responder chain diverts to the owning view controller before directing the event to the window. If the window cannot handle the event, UIKit delivers the event to the UIApplication object, and possibly to the app delegate if that object is an instance of UIResponder and not already part of the responder chain.基于ResponderChain实现对象交互我们可以借用responder chain实现了一个自己的事件传递链。1234567891011121314151617181920//UIResponder的分类//.h文件#import &lt;UIKit/UIKit.h&gt;@interface UIResponder (Router)- (void)routerEventWithName:(NSString *)eventName userInfo:(NSDictionary *)userInfo;@end//.m文件#import "UIResponder+Router.h"@implementation UIResponder (Router)- (void)routerEventWithName:(NSString *)eventName userInfo:(NSDictionary *)userInfo &#123; [[self nextResponder] routerEventWithName:eventName userInfo:userInfo];&#125;@end123456789101112131415161718192021222324252627282930313233343536//NSObject//.h文件#import &lt;Foundation/Foundation.h&gt;@interface NSObject (Invocation)- (NSInvocation *)createInvocationWithSelector:(SEL)aSelector;@end//.m文件#import "NSObject+Invocation.h"@implementation NSObject (Invocation)- (NSInvocation *)createInvocationWithSelector:(SEL)aSelector &#123; //1、创建签名对象 NSMethodSignature *signature = [[self class] instanceMethodSignatureForSelector:aSelector]; //2、判断传入的方法是否存在 if (signature==nil) &#123; //传入的方法不存在 就抛异常 NSString*info = [NSString stringWithFormat:@"-[%@ %@]:unrecognized selector sent to instance",[self class],NSStringFromSelector(aSelector)]; @throw [[NSException alloc] initWithName:@"方法没有" reason:info userInfo:nil]; return nil; &#125; //3、、创建NSInvocation对象 NSInvocation*invocation = [NSInvocation invocationWithMethodSignature:signature]; //4、保存方法所属的对象 invocation.target = self; invocation.selector = aSelector; return invocation;&#125;@end在需要响应事件的类中重载routerEventWithName::方法123- (void)routerEventWithName:(NSString *)eventName userInfo:(NSDictionary *)userInfo &#123; [self.eventProxy handleEvent:eventName userInfo:userInfo];&#125;使用EventProxy类来专门处理对应的事件1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859//EventProxy.h#import &lt;Foundation/Foundation.h&gt;@interface EventProxy : NSObject- (void)handleEvent:(NSString *)eventName userInfo:(NSDictionary *)userInfo;@end//EventProxy.m#import "EventProxy.h"#import "ResponderChainDefine.h"#import "UIResponder+Router.h"#import "NSObject+Invocation.h"@interface EventProxy ()@property (nonatomic, strong) NSDictionary *eventStrategy;@end@implementation EventProxy- (void)handleEvent:(NSString *)eventName userInfo:(NSDictionary *)userInfo &#123; NSInvocation *invocation = self.eventStrategy[eventName]; [invocation setArgument:&amp;userInfo atIndex:2]; [invocation invoke];&#125;- (void)cellLeftButtonClick:(NSDictionary *)userInfo &#123; NSIndexPath *indexPath = userInfo[@"indexPath"]; NSLog(@"indexPath:section:%ld, row:%ld 左边按钮被点击啦！",indexPath.section, indexPath.row);&#125;- (void)cellMiddleButtonClick:(NSDictionary *)userInfo &#123; NSIndexPath *indexPath = userInfo[@"indexPath"]; NSLog(@"indexPath:section:%ld, row:%ld 中间按钮被点击啦！",indexPath.section, indexPath.row);&#125;- (void)cellRightButtonClick:(NSDictionary *)userInfo &#123; NSIndexPath *indexPath = userInfo[@"indexPath"]; NSLog(@"indexPath:section:%ld, row:%ld 右边按钮被点击啦！",indexPath.section, indexPath.row);&#125;#pragma mark - getter &amp; setter- (NSDictionary &lt;NSString *, NSInvocation *&gt;*)eventStrategy &#123; if (!_eventStrategy) &#123; _eventStrategy = @&#123; kTableViewCellEventTappedLeftButton:[self createInvocationWithSelector:@selector(cellLeftButtonClick:)], kTableViewCellEventTappedMiddleButton:[self createInvocationWithSelector:@selector(cellMiddleButtonClick:)], kTableViewCellEventTappedRightButton:[self createInvocationWithSelector:@selector(cellRightButtonClick:)] &#125;; &#125; return _eventStrategy;&#125;@end在TableViewCell的事件中，调用routerEventWithName:userInfo:方法，就会调用到EventProxy类中的方法。123456789101112131415@implementation TableViewCell- (IBAction)leftButtonClick:(UIButton *)sender &#123; [self routerEventWithName:kTableViewCellEventTappedLeftButton userInfo:@&#123;@"indexPath":self.indexPath&#125;];&#125;- (IBAction)middelButtonClick:(UIButton *)sender &#123; [self routerEventWithName:kTableViewCellEventTappedMiddleButton userInfo:@&#123;@"indexPath":self.indexPath&#125;];&#125;- (IBAction)rightButtonClick:(UIButton *)sender &#123; [self routerEventWithName:kTableViewCellEventTappedRightButton userInfo:@&#123;@"indexPath":self.indexPath&#125;];&#125;@end总结使用这种基于Responder Chain的方式来传递事件，在复杂UI层级的页面中，可以避免无谓的delegate声明。事件处理的逻辑得到归拢，在这个方法里面下断点就能够管理所有的事件处理。参考文章Using Responders and the Responder Chain to Handle Events一种基于ResponderChain的对象交互方式responderChainDemo]]></content>
      <categories>
        <category>iOS 技巧</category>
      </categories>
      <tags>
        <tag>事件响应链  responder chain</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS长按移动Table View Cells]]></title>
    <url>%2F2018%2F01%2F19%2FiOS%E9%95%BF%E6%8C%89%E7%A7%BB%E5%8A%A8Table%20View%20Cells%2F</url>
    <content type="text"><![CDATA[前言最近参与了事务流程工具化组件的开发，其中有一个模块需要通过长按移动Table View Cells，来达到调整任务的需求，再次记录下开发过程中的实现思路。完成后的效果如下图所示：实现思路添加手势首先给 collection view 添加一个 UILongGestureRecognizer,在项目中一般使用懒加载的方式来对对象进行初始化：12345678910111213141516171819- (UICollectionView *)collectionView &#123; if (!_collectionView) &#123; _collectionView = [[UICollectionView alloc] initWithFrame:CGRectZero collectionViewLayout:self.flowLayout]; _collectionView.backgroundColor = [UIColor whiteColor]; _collectionView.dataSource = self; _collectionView.delegate = self; [_collectionView registerClass:[TLCMainCollectionViewCell class] forCellWithReuseIdentifier:[TLCMainCollectionViewCell identifier]]; _collectionView.showsHorizontalScrollIndicator = NO; _collectionView.showsVerticalScrollIndicator = NO; _collectionView.bounces = YES; _collectionView.decelerationRate = 0; [_collectionView addGestureRecognizer:self.longPress]; &#125; return _collectionView;&#125;123456- (UILongPressGestureRecognizer *)longPress &#123; if (!_longPress) &#123; _longPress = [[UILongPressGestureRecognizer alloc] initWithTarget:self action:@selector(longPressGestureRecognized:)]; &#125; return _longPress;&#125;在用户长按后，触犯长按事件，先获取到当前手势所在的collection view位置，再做后续的处理。12345678910111213141516171819202122232425- (void)longPressGestureRecognized:(UILongPressGestureRecognizer *)sender &#123; CGPoint location = [sender locationInView:sender.view]; UIGestureRecognizerState state = sender.state; switch (state) &#123; case UIGestureRecognizerStateBegan: &#123; [self handleLongPressStateBeganWithLocation:location]; &#125; break; case UIGestureRecognizerStateChanged: &#123; &#125; break; case UIGestureRecognizerStateEnded: case UIGestureRecognizerStateCancelled: &#123; [self longGestureEndedOrCancelledWithLocation:location]; &#125; break; default: break; &#125;&#125;长按手势状态为开始主要处理两个方面的事务，一为获取当前长按手势所对应的Table View Cell的镜像，将其添加到 Collection View上。二为一些初始状态的设置，后续在移动后网络请求出错及判断当前手势所处的Table View和上一次是否一致需要使用到。最后调用startPageEdgeScroll开启定时器。123456789101112131415161718192021222324252627282930- (void)handleLongPressStateBeganWithLocation:(CGPoint)location &#123; TLCMainCollectionViewCell *selectedCollectionViewCell = [self currentTouchedCollectionCellWithLocation:location]; NSIndexPath *touchIndexPath = [self longGestureBeganIndexPathForRowAtPoint:location atTableView:selectedCollectionViewCell.tableView]; if (!selectedCollectionViewCell || !touchIndexPath) &#123; return ; &#125; self.selectedCollectionViewCellRow = [self.collectionView indexPathForCell:selectedCollectionViewCell].row; // 已完成的任务，不支持排序 TLPlanItem *selectedItem = [self.viewModel itemAtIndex:self.selectedCollectionViewCellRow subItemIndex:touchIndexPath.section]; if (!selectedItem || selectedItem.finish) &#123; return; &#125; selectedItem.isHidden = YES; self.snapshotView = [self snapshotViewWithTableView:selectedCollectionViewCell.tableView atIndexPath:touchIndexPath]; [self.collectionView addSubview:self.snapshotView]; self.selectedIndexPath = touchIndexPath; self.originalSelectedIndexPathSection = touchIndexPath.section; self.originalCollectionViewCellRow = self.selectedCollectionViewCellRow; self.previousPoint = CGPointZero; [self startPageEdgeScroll];&#125;长按手势状态为改变在longPressGestureRecognized方法中，可以发现，长按手势状态改变时，并未做任何的操作，主要原因是如果在此做Table View Cells的移动操作，如果数据超过一屏幕，无法自动将未在屏幕上的数据滚动显示出来。所以在长按手势状态为开始时，如果触摸点在Table View Cell上，开启定时器，来处理长按手势状态为改变时的情况。1234- (void)startPageEdgeScroll &#123; self.edgeScrollTimer = [CADisplayLink displayLinkWithTarget:self selector:@selector(pageEdgeScrollEvent)]; [self.edgeScrollTimer addToRunLoop:[NSRunLoop mainRunLoop] forMode:NSRunLoopCommonModes];&#125;在定时器触发的事件中，处理两个方面的事情，移动cell和滚动ScrollView。12345678910111213- (void)pageEdgeScrollEvent &#123; [self longGestureChanged:self.longPress]; CGFloat snapshotViewCenterOffsetX = [self touchSnapshotViewCenterOffsetX]; if (fabs(snapshotViewCenterOffsetX) &gt; (TLCMainViewControllerFlowLayoutWidthOffset-20)) &#123; //横向滚动 [self handleScrollViewHorizontalScroll:self.collectionView viewCenterOffsetX:snapshotViewCenterOffsetX]; &#125; else &#123; //垂直滚动 [self handleScrollViewVerticalScroll:[self selectedCollectionViewCellTableView]]; &#125;&#125;在长按手势触摸点位置改变时，处理对应cell的移除和插入动作。横向滚动和垂直滚动主要是根据不同情况设置对应的Table View 和 Collection View的内容偏移量。可以在文末的链接中查看源码。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172- (void)longGestureChanged:(UILongPressGestureRecognizer *)sender &#123; CGPoint currentPoint = [sender locationInView:sender.view]; TLCMainCollectionViewCell *currentCollectionViewCell = [self currentTouchedCollectionCellWithLocation:currentPoint]; if (!currentCollectionViewCell) &#123; currentCollectionViewCell = [self collectionViewCellAtRow:self.selectedCollectionViewCellRow]; &#125; TLCMainCollectionViewCell *lasetSelectedCollectionViewCell = [self collectionViewCellAtRow:self.selectedCollectionViewCellRow]; //判断targetTableView是否改变 BOOL isTargetTableViewChanged = NO; if (self.selectedCollectionViewCellRow != currentCollectionViewCell.indexPath.row) &#123; isTargetTableViewChanged = YES; self.selectedCollectionViewCellRow = currentCollectionViewCell.indexPath.row; &#125; //获取到需要移动到的目标indexpath NSIndexPath *targetIndexPath = [self longGestureChangeIndexPathForRowAtPoint:currentPoint collectionViewCell:currentCollectionViewCell]; NSIndexPath *lastSelectedIndexPath = self.selectedIndexPath; TLCMainCollectionViewCell *selectedCollectionViewCell = [self collectionViewCellAtRow:self.selectedCollectionViewCellRow]; //判断跟上一次长按手势所处的Table View是否相同，如果相同，移动cell， //如果不同，删除上一次所定义的cell，插入到当前位置 if (isTargetTableViewChanged) &#123; if ([[self selectedCollectionViewCellTableView] numberOfSections]&gt;targetIndexPath.section) &#123; [[self selectedCollectionViewCellTableView] scrollToRowAtIndexPath:targetIndexPath atScrollPosition:UITableViewScrollPositionNone animated:YES]; &#125; TLPlanItem *moveItem = [self.viewModel itemAtIndex:lasetSelectedCollectionViewCell.indexPath.row subItemIndex:lastSelectedIndexPath.section]; [self.viewModel removeObject:moveItem itemIndex:lasetSelectedCollectionViewCell.indexPath.row]; [self.viewModel insertItem:moveItem index:self.selectedCollectionViewCellRow subItemIndex:targetIndexPath.section]; [lasetSelectedCollectionViewCell updateCellWithData:[self planItemsAtIndex:lasetSelectedCollectionViewCell.indexPath.row]]; [lasetSelectedCollectionViewCell.tableView deleteSections:[NSIndexSet indexSetWithIndex:lastSelectedIndexPath.section] withRowAnimation:UITableViewRowAnimationNone]; [selectedCollectionViewCell updateCellWithData:[self planItemsAtIndex:self.selectedCollectionViewCellRow]]; [selectedCollectionViewCell.tableView insertSections:[NSIndexSet indexSetWithIndex:targetIndexPath.section] withRowAnimation:UITableViewRowAnimationNone]; &#125; else &#123; BOOL isSameSection = lastSelectedIndexPath.section == targetIndexPath.section; UITableViewCell *targetCell = [self tableView:[self selectedCollectionViewCellTableView] selectedCellAtSection:targetIndexPath.section]; if (isSameSection || !targetCell ) &#123; [self modifySnapshotViewFrameWithTouchPoint:currentPoint]; return; &#125; TLPlanItem *item = [self.viewModel itemAtIndex:self.selectedCollectionViewCellRow subItemIndex:lastSelectedIndexPath.section]; [self.viewModel removeObject:item itemIndex:self.selectedCollectionViewCellRow]; [self.viewModel insertItem:item index:self.selectedCollectionViewCellRow subItemIndex:targetIndexPath.section]; [selectedCollectionViewCell updateCellWithData:[self planItemsAtIndex:self.selectedCollectionViewCellRow]]; [selectedCollectionViewCell.tableView moveSection:lastSelectedIndexPath.section toSection:targetIndexPath.section]; &#125; self.selectedIndexPath = targetIndexPath; //改变长按cell镜像的位置 [self modifySnapshotViewFrameWithTouchPoint:currentPoint];&#125;长按手势状态为取消或结束取消计时器，设置Collection View的偏移量，让其Collection View Cell位于屏幕的中心，发送网络请求，去调整任务的排序，同时将镜像视图隐藏，并将其所对应的Table View Cell显示出来。12345678910111213141516171819202122232425- (void)longGestureEndedOrCancelledWithLocation:(CGPoint)location &#123; [self stopEdgeScrollTimer]; CGPoint contentOffset = [self.flowLayout targetContentOffsetForProposedContentOffset:self.collectionView.contentOffset withScrollingVelocity:CGPointZero]; [self.collectionView setContentOffset:contentOffset animated:YES]; UITableViewCell *targetCell = [[self selectedCollectionViewCellTableView] cellForRowAtIndexPath:self.selectedIndexPath]; if ([self canAdjustPlanRanking]) &#123; [self adjustPlanRanking]; &#125; TLPlanItem *slectedItem = [self.viewModel itemAtIndex:self.selectedCollectionViewCellRow subItemIndex:self.selectedIndexPath.section]; [UIView animateWithDuration:0.25 animations:^&#123; self.snapshotView.transform = CGAffineTransformIdentity; self.snapshotView.frame = [self snapshotViewFrameWithCell:targetCell]; &#125; completion:^(BOOL finished) &#123; targetCell.hidden = NO; slectedItem.isHidden = NO; [self.snapshotView removeFromSuperview]; self.snapshotView = nil; &#125;];&#125;数据的处理在移动和插入Table View Cell时，需要将其所对应的数据做响应的改变，数据相关的操作均放在TLCMainViewModel对象中。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118@interface TLCMainViewModel : NSObject /** 今日要做、下一步要做和以后要做 */@property (nonatomic, readonly, strong) NSArray &lt;NSString *&gt; *titleArray; /** 获取计划列表 @param completion TLTodoModel */- (void)obtainTotalPlanListWithTypeCompletion:(TLSDKCompletionBlk)completion;/** 添加计划 @param requestItem requestItem @param completion 完成回调 */- (void)addPlanWithReq:(TLPlanItemReq *)requestItem atIndexPath:(NSIndexPath *)indexPath completion:(TLSDKCompletionBlk)completion;/** 返回显示的collectionViewCell的个数 @return 数据的个数 */- (NSInteger)numberOfItems;/** 根据type获取对应的数据 @param index 位置 @return 此计划所对应的数据 */- (NSMutableArray&lt;TLPlanItem *&gt; *)planItemsAtIndex:(NSInteger)index;/** 删除某个计划 @param itemIndex 单项数据在数组中的位置，如今日计划中的数据，itemIndex为0 @param subItemIndex 单项数据数组中所在的位置 @param completion 完成回调 */- (void)deletePlanAtItemIndex:(NSInteger)itemIndex subItemIndex:(NSInteger)subItemIndex completion:(dispatch_block_t)completion;/** 修改计划状态：完成与非完成 @param itemIndex 单项数据在数组中的位置，如今日计划中的数据，itemIndex为0 @param subItemIndex 单项数据数组中所在的位置 @param completion 完成回调 */- (void)modiflyPlanStateAtItemIndex:(NSInteger)itemIndex subItemIndex:(NSInteger)subItemIndex completion:(TLSDKCompletionBlk)completion;/** 修改计划的title和重点标记状态 @param itemIndex 单项数据在数组中的位置，如今日计划中的数据，itemIndex为0 @param subItemIndex 单项数据数组中所在的位置 @param targetItem 目标对象 @param completion 完成回调 */- (void)modiflyItemAtIndex:(NSInteger)itemIndex subItemIndex:(NSInteger)subItemIndex targetItem:(TLPlanItem *)targetItem completion:(dispatch_block_t)completion;/** 移除数据 @param item item @param itemIndex 单项数据在数组中的位置 */- (void)removeObject:(TLPlanItem *)item itemIndex:(NSInteger)itemIndex;/** 插入数据 @param item 插入的对象模型 @param itemIndex 单项数据在数组中的位置，如今日计划中的数据，itemIndex为0 @param subItemIndex 单项数据数组中所在的位置 */- (void)insertItem:(TLPlanItem *)item index:(NSInteger)itemIndex subItemIndex:(NSInteger)subItemIndex;/** 获取数据 @param itemIndex 一级index @param subItemIndex 二级index @return 数据模型 */- (TLPlanItem *)itemAtIndex:(NSInteger)itemIndex subItemIndex:(NSInteger)subItemIndex; /** 重置数据 */- (void)reset;/** 保存长按开始时的数据 */- (void)storePressBeginState;@end代码完善cell未居中显示问题2018年2月1号在iPhone系统版本为iOS8.x和iOS9.x时，会出现以后要做界面不会回弹的情况。如下图所示：经排查，是在UICollectionViewFlowLayout类中的1- (CGPoint)targetContentOffsetForProposedContentOffset:(CGPoint)proposedContentOffset withScrollingVelocity:(CGPoint)velocity方法计算得出的proposedContentOffset有偏差，修改后如下所示：1234567891011121314151617181920212223242526- (CGPoint)targetContentOffsetForProposedContentOffset:(CGPoint)proposedContentOffset withScrollingVelocity:(CGPoint)velocity &#123; CGFloat rawPageValue = self.collectionView.contentOffset.x / [self tlc_pageWidth]; CGFloat currentPage = (velocity.x &gt; 0.0) ? floor(rawPageValue) : ceil(rawPageValue); CGFloat nextPage = (velocity.x &gt; 0.0) ? ceil(rawPageValue) : floor(rawPageValue); BOOL pannedLessThanAPage = fabs(1 + currentPage - rawPageValue) &gt; 0.5; BOOL flicked = fabs(velocity.x) &gt; [self tlc_flickVelocity]; CGFloat actualPage = 0.0; if (pannedLessThanAPage &amp;&amp; flicked) &#123; proposedContentOffset.x = nextPage * [self tlc_pageWidth]; actualPage = nextPage; &#125; else &#123; proposedContentOffset.x = round(rawPageValue) * [self tlc_pageWidth]; actualPage = round(rawPageValue); &#125; if (lround(actualPage) &gt;= 1) &#123; proposedContentOffset.x -= 4.5; &#125; //下面为添加的代码 if (lround(actualPage) &gt;= 2) &#123; proposedContentOffset.x = self.collectionView.contentSize.width - TLCScreenWidth; &#125; return proposedContentOffset;&#125;在系统版本为iOS9.x时，输入框会上一段距离问题2018年2月12号在机型为iPhone SE，系统版本为iOS9.x时，新建计划时，新建窗口会上移一段，如下图所示：分析发现，应该是监听键盘高度变化时，输入框的高度计算在特定机型的特定版本上计算错误，将原有的计算frame的来布局的方式改为自动布局。监听键盘高度改变的代码修改后如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495- (void)viewWillAppear:(BOOL)animated&#123; [super viewWillAppear:animated]; [self addObserverForKeybord];&#125;- (void)viewWillDisappear:(BOOL)animated &#123; [super viewWillDisappear:animated]; [self.view endEditing:YES]; [self removeobserverForKeybord];&#125;#pragma mark - keyboard observer- (void)addObserverForKeybord &#123; [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(keyboardWillShow:) name:UIKeyboardWillShowNotification object:nil]; [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(keyboardWillHide:) name:UIKeyboardWillHideNotification object:nil];&#125;- (void)removeobserverForKeybord &#123; [[NSNotificationCenter defaultCenter] removeObserver:self name:UIKeyboardWillShowNotification object:nil]; [[NSNotificationCenter defaultCenter] removeObserver:self name:UIKeyboardWillHideNotification object:nil];&#125;- (void)keyboardWillShow:(NSNotification *)notification &#123; CGRect keyboardBounds; [[notification.userInfo valueForKey:UIKeyboardFrameEndUserInfoKey] getValue:&amp;keyboardBounds]; NSNumber *duration = [notification.userInfo objectForKey:UIKeyboardAnimationDurationUserInfoKey]; NSNumber *curve = [notification.userInfo objectForKey:UIKeyboardAnimationCurveUserInfoKey]; keyboardBounds = [self.view convertRect:keyboardBounds toView:nil]; [self.inputProjectView mas_updateConstraints:^(MASConstraintMaker *make) &#123; make.bottom.equalTo(self.view).offset(-CGRectGetHeight(keyboardBounds)); &#125;]; //设置动画 [UIView beginAnimations:nil context:NULL]; [UIView setAnimationBeginsFromCurrentState:YES]; [UIView setAnimationDuration:[duration doubleValue]]; [UIView setAnimationCurve:[curve intValue]]; [self.inputProjectView layoutIfNeeded]; [UIView commitAnimations];&#125;- (void)keyboardWillHide:(NSNotification *)notification &#123; if([self.inputProjectView inputText].length &gt; 0) &#123; [self.inputProjectView resetText]; &#125; CGRect keyboardBounds; [[notification.userInfo valueForKey:UIKeyboardFrameEndUserInfoKey] getValue:&amp;keyboardBounds]; NSNumber *duration = [notification.userInfo objectForKey:UIKeyboardAnimationDurationUserInfoKey]; NSNumber *curve = [notification.userInfo objectForKey:UIKeyboardAnimationCurveUserInfoKey]; keyboardBounds = [self.view convertRect:keyboardBounds toView:nil]; [self.inputProjectView mas_updateConstraints:^(MASConstraintMaker *make) &#123; if (@available(iOS 11.0, *)) &#123; make.bottom.equalTo(self.view).offset(self.view.safeAreaInsets.bottom+88); &#125; else &#123; make.bottom.equalTo(self.view).offset(88); &#125; make.height.mas_equalTo(88); &#125;]; //设置动画 [UIView beginAnimations:nil context:NULL]; [UIView setAnimationBeginsFromCurrentState:YES]; [UIView setAnimationDuration:[duration doubleValue]]; [UIView setAnimationCurve:[curve intValue]]; [self.inputProjectView layoutIfNeeded]; [UIView commitAnimations];&#125;切换输入法时，输入框被键盘遮住问题在修复此问题后，自测时发现，输入法由简体拼音切换为表情符号时，输入框会被键盘挡住，在代码中打断点发现UIKeyboardWillShowNotification和UIKeyboardWillChangeFrameNotification通知均未被触发，同时对比微信发现，切换输入法时，同时开启了自动校正功能，所以参考添加如下代码：1_textView.internalTextView.autocorrectionType = UITextAutocorrectionTypeYes;解决切换输入法时，输入框被键盘遮住的问题。总结除了上述Table View Cell移动的操作，在项目中还处理了创建事务和事务详情相关的业务。在整个过程中，比较棘手的还是Table View Cell的移动，在开发过程中，有时数据的移动和Table View Cell的移动未对应上，造成Table View Cell布局错乱，排查了很久。在项目开发过程中，还是需要仔细去分析需求。文章所对应的Demo请点这里]]></content>
      <categories>
        <category>UI</category>
      </categories>
      <tags>
        <tag>UI 长按移动 滚动</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS深拷贝和浅拷贝]]></title>
    <url>%2F2017%2F12%2F14%2FiOS%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D%2F</url>
    <content type="text"><![CDATA[在工作中，有时会涉及到深拷贝和浅拷贝的内容，发现有些地方理解的不够透彻，所以在网上搜集资料总结一下，主要分四个方面来介绍下iOS中深拷贝和浅拷贝：对象的拷贝；集合的拷贝；如何对集合进行深拷贝？总结对象的拷贝对对象进行拷贝，通过调用copy或mutableCopy方法来实现：调用 copy方法返回的对象为不可变对象,需要实现NSCopying协议 ；调用mutableCopy方法返回的对象为可变对象，需要实现NSMutableCopying协议 ；上图是苹果文档中关于对象拷贝的实例图，从图中可知：浅拷贝：object A和object B及其属性使用同样的内存地址，简单说明的话，可以认为是指针复制；深拷贝：object A和object B及其属性使用不同的内存地址，简单说明的话，可以认为是内容复制。下面通过分析NSString、NSMutableString、和自定义对象DBTestModel，调用copy和mutableCopy之后，分析其返回的对象及此对象的属性的内存地址来判断其行为是深拷贝还是浅拷贝。NSString通过打印的信息可知：对象string调用copy方法后返回的对象copySting，其所对应的内存地址和对象string一致，即为指针复制；对象string调用mutableCopy方法后返回的对象mutaCopySting，其所对应的内存地址和对象string不一致，即为指内容复制；NSMutableString通过打印的信息可知：对象mutaString调用copy方法后返回的对象copyMutaString，其所对应的内存地址和对象mutaString不一致，即为内容复制；对象mutaString调用mutableCopy方法后返回的对象mutaCopyMutaString，其所对应的内存地址和对象mutaString不一致，即为指内容复制；DBTestModel下面为自定义的对象’DBTestModel’:123456789101112131415#import &lt;Foundation/Foundation.h&gt;#import &lt;Mantle/Mantle.h&gt;@interface DBTestModel : MTLModel@property (nonatomic, copy) NSString *text;@property (nonatomic, strong) NSArray *sourceArray;@property (nonatomic, strong) NSMutableArray *mutableArray;- (instancetype)initWithText:(NSString *)text sourceArray:(NSArray *)sourceArray mutableArray:(NSMutableArray *)mutableArray;@end定义了三个属性，text、sourceArray、mutableArray。1234567891011121314151617181920212223242526272829303132- (void)testCustomObject &#123; NSMutableArray *mutableArray = [NSMutableArray array]; DBTestModel *model = [[DBTestModel alloc] initWithText:@"text" sourceArray:@[@"test1",@"test2"] mutableArray:mutableArray]; DBTestModel *copyModel = [model copy]; DBTestModel *mutaCopyModel = [model mutableCopy]; NSLog(@"DBTestModel memory address"); NSLog(@"original :%p", model); NSLog(@"copy :%p", copyModel); NSLog(@"mutableCopy:%p", mutaCopyModel); NSLog(@"\n"); NSLog(@"text memory address"); NSLog(@"original :%p", model.text); NSLog(@"copy :%p", copyModel.text); NSLog(@"mutableCopy:%p", mutaCopyModel.text); NSLog(@"\n"); NSLog(@"sourceArray memory address"); NSLog(@"original :%p", model.sourceArray); NSLog(@"copy :%p", copyModel.sourceArray); NSLog(@"mutableCopy:%p", mutaCopyModel.sourceArray); NSLog(@"\n"); NSLog(@"mutableArray memory address"); NSLog(@"original :%p", model.mutableArray); NSLog(@"copy :%p", copyModel.mutableArray); NSLog(@"mutableCopy:%p", mutaCopyModel.mutableArray); NSLog(@"\n"); &#125;打印结果如下：分析其打印数据可知：除DBTestModel实例对象中的属性text和sourceArray调用copy后，没有产生一个新的对象，为指针复制，其余均为内容复制。集合的拷贝不可变集合NSArray123456789101112131415161718192021222324252627282930- (void)testCollectiveCopy &#123; NSMutableArray *mutableArray1 = [NSMutableArray array]; DBTestModel *model1 = [[DBTestModel alloc] initWithText:@"text" sourceArray:@[@"test1",@"test2"] mutableArray:mutableArray1]; NSMutableArray *mutableArray2 = [NSMutableArray array]; DBTestModel *model2 = [[DBTestModel alloc] initWithText:@"text" sourceArray:@[@"test1",@"test2"] mutableArray:mutableArray2]; NSMutableArray *mutableArray3 = [NSMutableArray array]; DBTestModel *model3 = [[DBTestModel alloc] initWithText:@"text" sourceArray:@[@"test1",@"test2"] mutableArray:mutableArray3]; NSArray *array = @[model1,model2,model3]; NSArray *copyArray = [array copy]; NSMutableArray *mutaCopyArray = [array mutableCopy]; NSLog(@"\nNSArray memory address\noriginal :%p\ncopy :%p\nmutableCopy:%p\n", array,copyArray,mutaCopyArray); DBTestModel *firstCopyModel = [copyArray firstObject]; DBTestModel *firstMutableCopyModel = [mutaCopyArray firstObject]; NSLog(@"\nDBTestModel memory address\noriginal :%p\ncopy :%p\nmutableCopy:%p\n", model1,firstCopyModel,firstMutableCopyModel); NSLog(@"\nDBTestModel sourceArray memory address\noriginal :%p\ncopy :%p\nmutableCopy:%p\n", model1.sourceArray,firstCopyModel.sourceArray,firstMutableCopyModel.sourceArray); &#125;打印结果如下：分析其打印数据可知：除NSArray实例对象调用mutableCopy方法为内容复制外，其余的均为指针拷贝。可变集合NSMutableArray测试代码如下：1234567891011121314151617181920212223242526272829303132- (void)testCollectiveMutacopy &#123; NSMutableArray *mutableArray1 = [NSMutableArray array]; DBTestModel *model1 = [[DBTestModel alloc] initWithText:@"text" sourceArray:@[@"test1",@"test2"] mutableArray:mutableArray1]; NSMutableArray *mutableArray2 = [NSMutableArray array]; DBTestModel *model2 = [[DBTestModel alloc] initWithText:@"text" sourceArray:@[@"test1",@"test2"] mutableArray:mutableArray2]; NSMutableArray *mutableArray3 = [NSMutableArray array]; DBTestModel *model3 = [[DBTestModel alloc] initWithText:@"text" sourceArray:@[@"test1",@"test2"] mutableArray:mutableArray3]; NSArray *array1 = @[model1,model2,model3]; NSMutableArray *mutaArray = [NSMutableArray arrayWithArray:array1]; NSMutableArray *copyMutaArray = [mutaArray copy]; NSMutableArray *mutaCopyMutaArray= [mutaArray mutableCopy]; NSLog(@"\nNSMutableArray memory address\noriginal :%p\ncopy :%p\nmutableCopy:%p\n", mutaArray,copyMutaArray,mutaCopyMutaArray); DBTestModel *firstCopyModel = [copyMutaArray firstObject]; DBTestModel *firstMutableCopyModel = [mutaCopyMutaArray firstObject]; NSLog(@"\nDBTestModel memory address\noriginal :%p\ncopy :%p\nmutableCopy:%p\n", model1,firstCopyModel,firstMutableCopyModel); NSLog(@"\nDBTestModel sourceArray memory address\noriginal :%p\ncopy :%p\nmutableCopy:%p\n", model1.sourceArray,firstCopyModel.sourceArray,firstMutableCopyModel.sourceArray);&#125;测试结果如下：分析其打印数据可知：除NSMutableArray实例对象调用copy和mutableCopy方法为内容复制外，数组内容的元素均为指针拷贝。结合上述测试代码得出的测试数据，得出如下的表格：从上图可以看出，NSArray或NSMutableArray对象调用copy或mutableCopy时，得到的集合中的元素均为指针拷贝，如果想要实现集合对象的深拷贝，应该怎么办呢？如何对集合进行深拷贝？集合的单层深复制 (one-level-deep copy)可以用 initWithArray:copyItems: 将第二个参数设置为YES即可深复制，如1NSArray *copyArray = [[NSArray alloc] initWithArray:array copyItems:YES];如果你用这种方法深复制，集合里的每个对象都会收到 copyWithZone: 消息。同时集合里的对象需遵循 NSCopying 协议，否则会崩溃。得到的结果如下：从打印结果可以看出，拷贝后和拷贝前的数组中的DBTestModel对象的sourceArray的内存地址是相同的，这种拷贝方式只能够提供一层内存拷贝(one-level-deep copy)，而非真正的深复制。A true deep copy使用归档来实现:NSArray *copyArray = [NSKeyedUnarchiver unarchiveObjectWithData: [NSKeyedArchiver archivedDataWithRootObject:array]]; ####小结在项目中遇到需要需要对对象进行拷贝时，需要理解以下两点：1、对系统自带的不可变对象进行copy时，为指针复制；2、对集合类对象进行copy或mutableCopy时，集合类的元素均为指针复制；3、如只需对集合进行单层深拷贝，可以使用initWithArray:copyItems:类似的方法，将第二个参数设为YES来实现，如需实现集合的完全复制，可以使用归解档来实现；4、第三方库Mantle中的MTLModel类有实现NSCoding和NSCopying协议，自定义的类继承MTLModel类即可实现NSCoding和NSCopying协议。参考链接Object copyingCopying Collections]]></content>
      <categories>
        <category>基础知识</category>
      </categories>
      <tags>
        <tag>Object-C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MBProgressHUD 源码分析]]></title>
    <url>%2F2017%2F11%2F08%2FMBProgressHUD%20%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[在项目中经常会使用MBProgressHUD来实现弹窗提醒，所有来分析下MBProgressHUD这个三方库的代码。所分析的源码版本号为1.0.0。这篇总结主要分三个部分来介绍分析这个框架：代码结构方法调用流程图方法内部实现代码结构类图核心API属性12345678910111213141516171819/* * 用来推迟HUD的显示，避免HUD显示时间过短，出现一闪而逝的情况，默认值为0。 */@property (assign, nonatomic) NSTimeInterval graceTime;/** * HUD最短显示时间，单位为s，默认值为0。 */@property (assign, nonatomic) NSTimeInterval minShowTime;/** * HUD隐藏时，将其从父视图上移除 。默认值为NO */@property (assign, nonatomic) BOOL removeFromSuperViewOnHide; /** * HUD显示类型，默认为 MBProgressHUDModeIndeterminate. */@property (assign, nonatomic) MBProgressHUDMode mode;类方法1234567891011121314/** * 创建HUD,添加到提供的视图上并显示 */+ (instancetype)showHUDAddedTo:(UIView *)view animated:(BOOL)animated;/** * 找到最上层的HUD,并隐藏。 */+ (BOOL)hideHUDForView:(UIView *)view animated:(BOOL)animated;/** * 在传入的View上找到最上层的HUD并隐藏此HUD */+ (nullable MBProgressHUD *)HUDForView:(UIView *)view;实例方法1234567891011121314/** * 构造函数，用来初始化HUD */- (instancetype)initWithView:(UIView *)view;/** * 显示HUD */- (void)showAnimated:(BOOL)animated;/** * 隐藏HUD */- (void)hideAnimated:(BOOL)animated;方法调用流程图从MBProgressHUD提供的主要接口可以看出，主要有显示HUD和隐藏HUD这两个功能，一步步追溯，得出的方法调用流程图如下：方法内部实现方法的内部实现主要从两个方面来分析，显示HUD和隐藏HUD。显示HUD首先是MBProgressHUD的构造方法123456789+ (instancetype)showHUDAddedTo:(UIView *)view animated:(BOOL)animated &#123; //初始化MBProgressHUD MBProgressHUD *hud = [[self alloc] initWithView:view]; hud.removeFromSuperViewOnHide = YES; [view addSubview:hud]; [hud showAnimated:animated]; [[UINavigationBar appearance] setBarTintColor:nil]; return hud;&#125;首先进入- (id)initWithView:(UIView *)view方法，再进入- (instancetype)initWithFrame:(CGRect)frame方法，最后调用- (void)commonInit方法，进行属性的初始化和添加子视图。123456789101112131415161718192021222324- (void)commonInit &#123; // Set default values for properties _animationType = MBProgressHUDAnimationFade; _mode = MBProgressHUDModeIndeterminate; _margin = 20.0f; _opacity = 1.f; _defaultMotionEffectsEnabled = YES; // Default color, depending on the current iOS version BOOL isLegacy = kCFCoreFoundationVersionNumber &lt; kCFCoreFoundationVersionNumber_iOS_7_0; _contentColor = isLegacy ? [UIColor whiteColor] : [UIColor colorWithWhite:0.f alpha:0.7f]; // Transparent background self.opaque = NO; self.backgroundColor = [UIColor clearColor]; // Make it invisible for now self.alpha = 0.0f; self.autoresizingMask = UIViewAutoresizingFlexibleWidth | UIViewAutoresizingFlexibleHeight; self.layer.allowsGroupOpacity = NO; //添加子视图 [self setupViews]; //更新指示器 [self updateIndicators]; [self registerForNotifications];&#125;添加子视图都是常见的方式，让视图跟随陀螺仪运动，这个之前没有接触过，后续需要了解下。123456789101112131415161718192021222324252627- (void)updateBezelMotionEffects &#123;#if __IPHONE_OS_VERSION_MAX_ALLOWED &gt;= 70000 || TARGET_OS_TV MBBackgroundView *bezelView = self.bezelView; if (![bezelView respondsToSelector:@selector(addMotionEffect:)]) return; if (self.defaultMotionEffectsEnabled) &#123; CGFloat effectOffset = 10.f; UIInterpolatingMotionEffect *effectX = [[UIInterpolatingMotionEffect alloc] initWithKeyPath:@"center.x" type:UIInterpolatingMotionEffectTypeTiltAlongHorizontalAxis]; effectX.maximumRelativeValue = @(effectOffset); effectX.minimumRelativeValue = @(-effectOffset); UIInterpolatingMotionEffect *effectY = [[UIInterpolatingMotionEffect alloc] initWithKeyPath:@"center.y" type:UIInterpolatingMotionEffectTypeTiltAlongVerticalAxis]; effectY.maximumRelativeValue = @(effectOffset); effectY.minimumRelativeValue = @(-effectOffset); UIMotionEffectGroup *group = [[UIMotionEffectGroup alloc] init]; group.motionEffects = @[effectX, effectY]; [bezelView addMotionEffect:group]; &#125; else &#123; NSArray *effects = [bezelView motionEffects]; for (UIMotionEffect *effect in effects) &#123; [bezelView removeMotionEffect:effect]; &#125; &#125;#endif&#125;再主要看下更新指示器的代码。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061- (void)updateIndicators &#123; UIView *indicator = self.indicator; BOOL isActivityIndicator = [indicator isKindOfClass:[UIActivityIndicatorView class]]; BOOL isRoundIndicator = [indicator isKindOfClass:[MBRoundProgressView class]]; MBProgressHUDMode mode = self.mode; //菊花动画 if (mode == MBProgressHUDModeIndeterminate) &#123; if (!isActivityIndicator) &#123; // Update to indeterminate indicator [indicator removeFromSuperview]; indicator = [[UIActivityIndicatorView alloc] initWithActivityIndicatorStyle:UIActivityIndicatorViewStyleWhiteLarge]; [(UIActivityIndicatorView *)indicator startAnimating]; [self.bezelView addSubview:indicator]; &#125; &#125; //水平进度条动画 else if (mode == MBProgressHUDModeDeterminateHorizontalBar) &#123; // Update to bar determinate indicator [indicator removeFromSuperview]; indicator = [[MBBarProgressView alloc] init]; [self.bezelView addSubview:indicator]; &#125; //圆形进度动画 else if (mode == MBProgressHUDModeDeterminate || mode == MBProgressHUDModeAnnularDeterminate) &#123; if (!isRoundIndicator) &#123; // Update to determinante indicator [indicator removeFromSuperview]; indicator = [[MBRoundProgressView alloc] init]; [self.bezelView addSubview:indicator]; &#125; //环形动画 if (mode == MBProgressHUDModeAnnularDeterminate) &#123; [(MBRoundProgressView *)indicator setAnnular:YES]; &#125; &#125; //自定义动画 else if (mode == MBProgressHUDModeCustomView &amp;&amp; self.customView != indicator) &#123; // Update custom view indicator [indicator removeFromSuperview]; indicator = self.customView; [self.bezelView addSubview:indicator]; &#125; //只显示文本 else if (mode == MBProgressHUDModeText) &#123; [indicator removeFromSuperview]; indicator = nil; &#125; indicator.translatesAutoresizingMaskIntoConstraints = NO; self.indicator = indicator; if ([indicator respondsToSelector:@selector(setProgress:)]) &#123; [(id)indicator setValue:@(self.progress) forKey:@"progress"]; &#125; [indicator setContentCompressionResistancePriority:998.f forAxis:UILayoutConstraintAxisHorizontal]; [indicator setContentCompressionResistancePriority:998.f forAxis:UILayoutConstraintAxisVertical]; [self updateViewsForColor:self.contentColor]; [self setNeedsUpdateConstraints];&#125;在这个方法中，主要是根据显示的模式，将不同的indicator视图赋值给indicator属性。更新完指示器后，就是开始将视图显示在界面上。调用的是- (void)showAnimated:(BOOL)animated方法。1234567891011121314151617181920212223- (void)showAnimated:(BOOL)animated &#123; //保证当前线程是主线程 MBMainThreadAssert(); [self.minShowTimer invalidate]; self.useAnimation = animated; self.finished = NO; // 如果设置了宽限时间，则推迟HUD的显示 if (self.graceTime &gt; 0.0) &#123; NSTimer *timer = [NSTimer timerWithTimeInterval:self.graceTime target:self selector:@selector(handleGraceTimer:) userInfo:nil repeats:NO]; //默认把你的Timer以NSDefaultRunLoopMode添加到MainRunLoop上，而当当前视图在滚动时，当前的MainRunLoop是处于UITrackingRunLoopMode的模式下，在这个模式下，是不会处理NSDefaultRunLoopMode的消息，要想在scrollView滚动的同时Timer也执行的话，我们需要将Timer以NSRunLoopCommonModes的模式注册到当前RunLoop中. [[NSRunLoop currentRunLoop] addTimer:timer forMode:NSRunLoopCommonModes]; self.graceTimer = timer; &#125; // ... otherwise show the HUD immediately else &#123; [self showUsingAnimation:self.useAnimation]; &#125;&#125;在- (void)showAnimated:(BOOL)animated方法中，主要做的是判断是否设置了推迟显示HUD的时间，如果设置了，就推迟设置的时间再显示。最后，执行- (void)showUsingAnimation:(BOOL)animated方法。123456789101112131415161718192021222324252627- (void)showUsingAnimation:(BOOL)animated &#123; // Cancel any previous animations [self.bezelView.layer removeAllAnimations]; [self.backgroundView.layer removeAllAnimations]; // Cancel any scheduled hideDelayed: calls [self.hideDelayTimer invalidate]; //记录当前显示的时间，在HUD隐藏时，比较HUD显示到HUD隐藏之间的间隔与最小显示时间， //如果小于，继续显示，直到显示时间等于最小显示时间，再隐藏HUD self.showStarted = [NSDate date]; self.alpha = 1.f; // Needed in case we hide and re-show with the same NSProgress object attached. //好像是通过这个去刷新进度，这个需要再查下。 [self setNSProgressDisplayLinkEnabled:YES]; if (animated) &#123; [self animateIn:YES withType:self.animationType completion:NULL]; &#125; else &#123;#pragma clang diagnostic push#pragma clang diagnostic ignored "-Wdeprecated-declarations" self.bezelView.alpha = self.opacity;#pragma clang diagnostic pop self.backgroundView.alpha = 1.f; &#125;&#125;最后执行- (void)animateIn:(BOOL)animatingIn withType:(MBProgressHUDAnimation)type completion:(void(^)(BOOL finished))completion方法，这个方法显示和隐藏均会调用。12345678910111213141516171819202122232425262728293031323334353637383940414243//这个方法主要对self.bezelView视图进行动画- (void)animateIn:(BOOL)animatingIn withType:(MBProgressHUDAnimation)type completion:(void(^)(BOOL finished))completion &#123; // Automatically determine the correct zoom animation type if (type == MBProgressHUDAnimationZoom) &#123; type = animatingIn ? MBProgressHUDAnimationZoomIn : MBProgressHUDAnimationZoomOut; &#125; CGAffineTransform small = CGAffineTransformMakeScale(0.5f, 0.5f); CGAffineTransform large = CGAffineTransformMakeScale(1.5f, 1.5f); // Set starting state UIView *bezelView = self.bezelView; if (animatingIn &amp;&amp; bezelView.alpha == 0.f &amp;&amp; type == MBProgressHUDAnimationZoomIn) &#123; bezelView.transform = small; &#125; else if (animatingIn &amp;&amp; bezelView.alpha == 0.f &amp;&amp; type == MBProgressHUDAnimationZoomOut) &#123; bezelView.transform = large; &#125; // 使用动画 dispatch_block_t animations = ^&#123; if (animatingIn) &#123; bezelView.transform = CGAffineTransformIdentity; &#125; else if (!animatingIn &amp;&amp; type == MBProgressHUDAnimationZoomIn) &#123; bezelView.transform = large; &#125; else if (!animatingIn &amp;&amp; type == MBProgressHUDAnimationZoomOut) &#123; bezelView.transform = small; &#125;#pragma clang diagnostic push#pragma clang diagnostic ignored "-Wdeprecated-declarations" bezelView.alpha = animatingIn ? self.opacity : 0.f;#pragma clang diagnostic pop self.backgroundView.alpha = animatingIn ? 1.f : 0.f; &#125;; // Spring animations are nicer, but only available on iOS 7+#if __IPHONE_OS_VERSION_MAX_ALLOWED &gt;= 70000 || TARGET_OS_TV if (kCFCoreFoundationVersionNumber &gt;= kCFCoreFoundationVersionNumber_iOS_7_0) &#123; [UIView animateWithDuration:0.3 delay:0. usingSpringWithDamping:1.f initialSpringVelocity:0.f options:UIViewAnimationOptionBeginFromCurrentState animations:animations completion:completion]; return; &#125;#endif [UIView animateWithDuration:0.3 delay:0. options:UIViewAnimationOptionBeginFromCurrentState animations:animations completion:completion];&#125;从代码可以看出，这里只是对指示器的父视图做了放大缩小的动画。隐藏HUD1234567891011+ (BOOL)hideHUDForView:(UIView *)view animated:(BOOL)animated &#123; //获取当前显示的hud,如果存在，当前隐藏时，将其从父视图移除 MBProgressHUD *hud = [self HUDForView:view]; if (hud != nil) &#123; hud.removeFromSuperViewOnHide = YES; [hud hideAnimated:animated]; return YES; &#125; return NO;&#125;在这个方法的执行过程中，调用- (void)hideAnimated:(BOOL)animated方法。12345678910111213141516171819 - (void)hideAnimated:(BOOL)animated &#123; MBMainThreadAssert(); [self.graceTimer invalidate]; self.useAnimation = animated; self.finished = YES; // 如果设置了最小显示时间，计算HUD显示时长， // 如果HUD显示时长小于最小显示时间，延迟显示 if (self.minShowTime &gt; 0.0 &amp;&amp; self.showStarted) &#123; NSTimeInterval interv = [[NSDate date] timeIntervalSinceDate:self.showStarted]; if (interv &lt; self.minShowTime) &#123; NSTimer *timer = [NSTimer timerWithTimeInterval:(self.minShowTime - interv) target:self selector:@selector(handleMinShowTimer:) userInfo:nil repeats:NO]; [[NSRunLoop currentRunLoop] addTimer:timer forMode:NSRunLoopCommonModes]; self.minShowTimer = timer; return; &#125; &#125; // ... otherwise hide the HUD immediately [self hideUsingAnimation:self.useAnimation];&#125;- (void)hideAnimated:(BOOL)animated方法中，主要做的是判断是否需要推迟隐藏HUD，最后调用- (void)hideUsingAnimation:(BOOL)animated方法，12345678910111213141516- (void)hideUsingAnimation:(BOOL)animated &#123; //判断是否需要动画效果，如无，则直接隐藏 if (animated &amp;&amp; self.showStarted) &#123; self.showStarted = nil; //跟显示HUD差不多，只是指示器父视图没有做放大缩小的动画 [self animateIn:NO withType:self.animationType completion:^(BOOL finished) &#123; [self done]; &#125;]; &#125; else &#123; self.showStarted = nil; self.bezelView.alpha = 0.f; self.backgroundView.alpha = 1.f; [self done]; &#125;&#125;最后，调用- (void)done方法。这个方法主要负责属性的释放和隐藏完成回调的处理。- (void)done { // Cancel any scheduled hideDelayed: calls [self.hideDelayTimer invalidate]; //指示进度的显示问题，后续还需再补充 [self setNSProgressDisplayLinkEnabled:NO]; if (self.hasFinished) { self.alpha = 0.0f; if (self.removeFromSuperViewOnHide) { [self removeFromSuperview]; } } MBProgressHUDCompletionBlock completionBlock = self.completionBlock; if (completionBlock) { completionBlock(); } id&lt;MBProgressHUDDelegate&gt; delegate = self.delegate; if ([delegate respondsToSelector:@selector(hudWasHidden:)]) { [delegate performSelector:@selector(hudWasHidden:) withObject:self]; } } 总结从代码来看，MBProgressHUD这个三方库有几个地方值借鉴：graceTime和minShowTime，在开发的时候会出现显示HUD后，存在缓存或者网速较好时，HUD显示到HUD隐藏的时间较短，界面出现闪动的情况，这时，就可以通过设置graceTime和minShowTime来处理，达到更好的用户体验。 这个在封装弹窗控件时，可以参考。]]></content>
      <categories>
        <category>三方开源库</category>
      </categories>
      <tags>
        <tag>源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS布局与Masnory使用实践]]></title>
    <url>%2F2017%2F11%2F06%2FiOS%E5%B8%83%E5%B1%80%E4%B8%8EMasnory%E4%BD%BF%E7%94%A8%E5%AE%9E%E8%B7%B5%2F</url>
    <content type="text"><![CDATA[前言UI布局对于iOS开发者来说并不陌生，在iOS6之前，大家都是通过UI控件的Frame属性和Autoresizing Mask来进行UI布局的（简称为手动布局）。AutoLayout则是苹果公司在iOS6推出的一种基于约束的，描述性的布局系统（简称为自动布局），这里主要从四个方面来阐述iOS布局及实践。手动布局和自动布局AutoLayout原理AutoLayout的性能Masnory的使用首先对手动布局和自动布局做一个简单的介绍：手动布局和自动布局手动布局：指的是通过直接修改视图的frame属性的方式对界面进行布局。对于IOS的app开发者来说，不会像Android开发者一样为很多的屏幕尺寸来做界面适配，因此手动调整 frame的方式来布局也能工作良好。但是还是会有一些问题，如设备发生旋转、适配ipad等，并且保证视图原来之间的相对关系，则以上的方法都是无法解决的。如果要做这些适配，在AutoLayout未出来之前需要编写大量的代码，并且花费大量的调试适配时间。自动布局：指的是使用AutoLayout的方式对界面进行布局。AutoLayout 是苹果本身提倡的技术，在大部分情况下也能很好的提升开发效率，但是 AutoLayout对于复杂视图来说常常会产生严重的性能问题。随着视图数量的增长，AutoLayout 带来的 CPU 消耗会呈指数级上升。 如果对界面流畅度要求较高（如微博界面），可以通过提前计算好布局，在需要时一次性调整好对应属性 ，或者使用 ComponentKit、AsyncDisplayKit 等框架来处理界面布局。下面，我们来分析下 AutoLayout的原理。AutoLayout的原理这里通过使用Masonry来进行布局，从而来分析AutoLayout的原理，先简要了解下Masonry。Masonry是一个轻量级的布局框架，拥有自己的描述语法，采用更优雅的链式语法封装自动布局，简洁明了，并具有高可读性，而且同时支持 iOS 和 Max OS X。Masnory支持的常用属性如下：1234567891011@property (nonatomic, strong, readonly) MASConstraint *left; //左侧@property (nonatomic, strong, readonly) MASConstraint *top; //上侧@property (nonatomic, strong, readonly) MASConstraint *right; //右侧@property (nonatomic, strong, readonly) MASConstraint *bottom; //下侧@property (nonatomic, strong, readonly) MASConstraint *leading; //首部@property (nonatomic, strong, readonly) MASConstraint *trailing; //首部@property (nonatomic, strong, readonly) MASConstraint *width; //宽@property (nonatomic, strong, readonly) MASConstraint *height; //高@property (nonatomic, strong, readonly) MASConstraint *centerX; //横向中点@property (nonatomic, strong, readonly) MASConstraint *centerY; //纵向中点@property (nonatomic, strong, readonly) MASConstraint *baseline; //文本基线其中leading与left，trailing与right 在正常情况下是等价的，但是当一些布局是从右至左时(比如阿拉伯语) 则会对调。同时，在Masonry中能够添加AutoLayout约束有三个函数：123- (NSArray *)mas_makeConstraints:(void(^)(MASConstraintMaker *make))block;//只负责新增约束` AutoLayout`不能同时存在两条针对于同一对象的约束,否则会报错- (NSArray *)mas_updateConstraints:(void(^)(MASConstraintMaker *make))block;//针对上面的情况 会更新在block中出现的约束 不会导致出现两个相同约束的情况- (NSArray *)mas_remakeConstraints:(void(^)(MASConstraintMaker *make))block;//则会清除之前的所有约束 仅保留最新的约束我们在代码中，经常会使用到equalTo和mas_equalTo，那它们的区别是什么呢？从代码中找到他们的定义如下：123#define mas_equalTo(...) equalTo(MASBoxValue((__VA_ARGS__)))...#define MASBoxValue(value) _MASBoxValue(@encode(__typeof__((value))), (value))可以看到 mas_equalTo只是对其参数进行了一个BOX操作(装箱) ，所支持的类型，除了NSNumber支持的那些数值类型之外，还支持CGPoint，CGSize和UIEdgeInsets类型。下面，我们通过一个例子，一步步来看下界面是怎么布局的，代码如下：1234567891011121314151617181920212223242526272829303132333435363738394041- (void)viewDidLoad &#123; [super viewDidLoad]; self.view.backgroundColor = [UIColor blackColor]; UIView *v1 = [[UIView alloc] init]; v1.backgroundColor = [UIColor orangeColor]; [v1 showPlaceHolder]; UIView *v2 = [[UIView alloc] init]; v2.backgroundColor = [UIColor orangeColor]; [v2 showPlaceHolder]; UIView *v3 = [[UIView alloc] init]; v3.backgroundColor = [UIColor orangeColor]; [v3 showPlaceHolder]; [self.view addSubview:v1]; [self.view addSubview:v2]; [self.view addSubview:v3]; [v1 mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.top.mas_equalTo(100); make.leading.mas_equalTo(100); make.width.mas_equalTo(70); make.height.mas_equalTo(65); &#125;]; [v2 mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.top.equalTo(v1.mas_top); make.leading.mas_equalTo(v1.mas_trailing).offset(20); make.width.equalTo(v1.mas_width); make.height.equalTo(v1.mas_height); &#125;]; [v3 mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.top.equalTo(v1.mas_bottom).offset(20); make.leading.equalTo(v1.mas_leading); make.trailing.equalTo(v2.mas_trailing); make.height.equalTo(v1.mas_height); &#125;];&#125;界面运行结果如下图：下面，我们将界面中的左上角的视图视为视图1，右上角的视图视为视图2，底部视图视为视图3，使用x1、y1、m1、n1来标识视图1的left、top、width和height，以此类推。通过以上举例抽象出自动布局数学公式：将以上等式变形为：此时，以上方程组，大家肯定很熟悉了，也就是《线性代数》中的线性方程组，现在将以上线性方程组抽象为：上图表示“等式”方程组，那么是否还可以继续抽象？也就是说上述方程组能否完全表示未知元素之间与已知元素之间的关系，显然还不全面，因为还有（&lt;,&gt;,&lt;=,&gt;=）不等关系，因此将“=”等号抽象为关系”R”,在数学上关系R也就包括了“=”,”&lt;”,”&gt;”,”&lt;=”,”&gt;=”等关系。上述线程方程组变形为：（实质上，AutoLayout中所有的约束确实都是用数学关系式y R ax + b描述）现在已经将自动布局一步步抽象为数学公式，那么对视图的布局其实就是对线性方程组的求解。线性方程组解的情况有三种，实质上也对应着自动布局对视图的三种布局方案:唯一解：所有方程中的未知数能够解出唯一解。 充分约束：给一个视图添加的约束必须是充分的，才能正确布局一个视图；多个解：未知数不能求解出准确的唯一解，即未知数可能存在多个或者无限个解满足线性方程组。 欠约束：给视图所添加的约束不能够充分的表达视图的准确位置，在这种情况下自动布局会随意给视图一个布局方案，也就是自动布局中视图不能够正确布局或者视图丢失的情况。无解：不存在满足线性方程组的解。 冲突约束：给视图添加的约束表达视图布局出现了冲突，比如同时满足同一个视图宽度即为100又为200，这是不可能存在的。此时程序会出现崩溃。通过以上描述，将AutoLayout系统的作用描述如图所示：AutoLayout的性能从AutoLayout的原理，我们可以得出布局系统最后仍然需要通过frame来进行布局，相比原有的布局系统加入了从约束计算 出frame 的过程,那么这个过程对性能是否会影响呢？你可以在 这里 找到这次对 Layout 性能测量使用的代码。代码分别使用Auto Layout、嵌套视图层级中使用 Auto Layout和frame对 N 个视图进行布局，测算其运行时间。对视图数量在 1~35 之间布局时间进行测量，结果如下：对视图数量在 10~500 之间布局时间进行测量，结果如下：从上述的测试数据可以看出，使用frame、AutoLayout和嵌套视图层级中使用 Auto Layout进行布局、对应的视图数量分别为50个、6个和12个，所需要的时间就会在 16.67 ms左右。,而想要让 iOS 应用的视图保持 60 FPS 的刷新频率，我们必须在 1/60 = 16.67 ms 之内完成包括布局、绘制以及渲染等操作。综上所述，虽然说 Auto Layout 为开发者在多尺寸布局上提供了遍历，而且支持跨越视图层级的约束，但是由于其实现原理导致其时间复杂度为多项式时间，其性能损耗是仅使用 frame 的十几倍，所以在处理庞大的 UI界面时表现差强人意。Masnory的使用下面，我们通过4个实例，来了解下Masnory的使用。######case 1: 并排显示两个label，宽度由内容决定。父视图宽度不够时，优先显示右边label的内容。在默认情况下，我们没有设置各个布局的优先级，那么他就会优先显示左边的label，左边的完全显示后剩余的空间都是右边的label，如果整个空间宽度都不够左边的label的话，那么右边的label就没有显示的机会了。如果我们现在的需求是优先显示右边的label，左边的label内容超出的省略，这时就需要我们调整约束的优先级了。UIView中关于Content Hugging 和Content Compression Resistance的方法有：12345- (UILayoutPriority)contentHuggingPriorityForAxis:(UILayoutConstraintAxis)axis NS_AVAILABLE_IOS(6_0);- (void)setContentHuggingPriority:(UILayoutPriority)priority forAxis:(UILayoutConstraintAxis)axis NS_AVAILABLE_IOS(6_0);- (UILayoutPriority)contentCompressionResistancePriorityForAxis:(UILayoutConstraintAxis)axis NS_AVAILABLE_IOS(6_0);- (void)setContentCompressionResistancePriority:(UILayoutPriority)priority forAxis:(UILayoutConstraintAxis)axis NS_AVAILABLE_IOS(6_0);那么这两个东西到底是什么呢？可以这样形象的理解一下：contentHugging: 抱住使其在“内容大小”的基础上不能继续变大，这个属性的优先级越高，就要越“抱紧”视图里面的内容。也就是视图的大小不会随着父视图的扩大而扩大。contentCompression: 撑住使其在在其“内容大小”的基础上不能继续变小,这个属性的优先级越高，越不“容易”被压缩。也就是说，当整体的空间装不下所有的视图时，Content Compression Resistance优先级越高的，显示的内容越完整。这两个属性分别可以设置水平方向和垂直方向上的，而且一个默认优先级是250， 一个默认优先级是750. 因为这两个很有可能与其他Constraint冲突，所以优先级较低。1234static const UILayoutPriority UILayoutPriorityRequired NS_AVAILABLE_IOS(6_0) = 1000; // A required constraint. Do not exceed this.static const UILayoutPriority UILayoutPriorityDefaultHigh NS_AVAILABLE_IOS(6_0) = 750; // This is the priority level with which a button resists compressing its content.static const UILayoutPriority UILayoutPriorityDefaultLow NS_AVAILABLE_IOS(6_0) = 250; // This is the priority level at which a button hugs its contents horizontally.static const UILayoutPriority UILayoutPriorityFittingSizeLevel NS_AVAILABLE_IOS(6_0) = 50;1234567891011121314151617181920212223242526- (void)layoutPageSubViews &#123; [self.leftLabel mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.top.equalTo(self.contentView1.mas_top).with.offset(5); make.left.equalTo(self.contentView1.mas_left).with.offset(2); make.height.equalTo(@40); &#125;]; [self.rightLabel mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.left.equalTo(self.leftLabel.mas_right).with.offset(2); make.top.equalTo(self.contentView1.mas_top).with.offset(5); make.right.lessThanOrEqualTo(self.contentView1.mas_right).with.offset(-2); make.height.equalTo(@40); &#125;]; [self.leftLabel setContentHuggingPriority:UILayoutPriorityRequired forAxis:UILayoutConstraintAxisHorizontal]; [self.leftLabel setContentCompressionResistancePriority:UILayoutPriorityDefaultLow forAxis:UILayoutConstraintAxisHorizontal]; [self.rightLabel setContentHuggingPriority:UILayoutPriorityRequired forAxis:UILayoutConstraintAxisHorizontal]; [self.rightLabel setContentCompressionResistancePriority:UILayoutPriorityRequired forAxis:UILayoutConstraintAxisHorizontal];&#125;######case 2: 四个ImageView整体居中，可以任意显示、隐藏。下面的四个Switch控件分别控制上面对应位置的图片是否显示。分析:首先就是整体居中，为了实现这个，最简单的办法就是将四个图片“装进”一个容器View里面，然后让这个容器View在整个页面中居中即可。这样就不用控制每个图片的居中效果了。然后就是显示与隐藏。在这里我直接控制图片ImageView的宽度，宽度为0的时候不就“隐藏”了吗。具体代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142- (void)layoutPageSubViews &#123; [self.containerView mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.height.mas_equalTo(IMAGE_SIZE); make.centerX.equalTo(self.view.mas_centerX); make.top.equalTo(self.view.mas_top).offset(200); &#125;]; //分别设置每个imageView的宽高、左边、垂直中心约束，注意约束的对象 //每个View的左边约束和左边的View的右边相等 __block UIView *lastView = nil; __block MASConstraint *widthConstraint = nil; NSUInteger arrayCount = self.imageViews.count; [self.imageViews enumerateObjectsUsingBlock:^(UIView *view, NSUInteger idx, BOOL *stop) &#123; [view mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.left.equalTo(lastView ? lastView.mas_right : view.superview.mas_left); make.centerY.equalTo(view.superview.mas_centerY); if (idx == arrayCount - 1) &#123; make.right.equalTo(view.superview.mas_right); &#125; widthConstraint = make.width.mas_equalTo(IMAGE_SIZE); make.height.mas_equalTo(IMAGE_SIZE); [self.widthConstraints addObject:widthConstraint]; lastView = view; &#125;]; &#125;];&#125;#pragma mark - event response//点击switch按钮，如果打开，对应视图的宽约束设置为32，否则，设置为0- (IBAction)showOrHideImage:(UISwitch *)sender &#123; NSUInteger index = (NSUInteger) sender.tag; MASConstraint *width = self.widthConstraints[index]; if (sender.on) &#123; width.mas_equalTo(IMAGE_SIZE); &#125; else &#123; width.mas_equalTo(0); &#125;&#125;#####case 3: 子视图的宽度始终是父视图的四分之三（或者任意百分比）12345678910 //宽度为父view的宽度的四分之三 [subView mas_makeConstraints:^(MASConstraintMaker *make) &#123; //上下左贴边 make.left.equalTo(_containerView.mas_left); make.top.equalTo(_containerView.mas_top); make.bottom.equalTo(_containerView.mas_bottom); //宽度为父view的宽度的一半 make.width.equalTo(_containerView.mas_width).multipliedBy(0.75); &#125;];#####case 4 给同一个属性添加多重约束，实现复杂关系 - (void)layoutPageSubviews { [self.greenLabel mas_makeConstraints:^(MASConstraintMaker *make) { make.centerY.equalTo(self.containerView); make.right.lessThanOrEqualTo(self.containerView); make.left.greaterThanOrEqualTo(self.containerView.mas_right).multipliedBy((CGFloat)(1.0f / 3.0f)); for (UILabel *label in self.leftLabels) { make.left.greaterThanOrEqualTo(label.mas_right).offset(8); } }]; [self.greenLabel setContentCompressionResistancePriority:UILayoutPriorityRequired forAxis:UILayoutConstraintAxisHorizontal]; } 总结通过上述分析，我们可以发现：AutoLayout的原理就是对线性方程组或者不等式的求解，最终使用frame来绘制视图；使用AutoLayout进行布局时， 由于其实现原理导致其时间复杂度为多项式时间，其性能损耗是仅使用 frame 的十几倍，所以在处理庞大的 UI界面时表现差强人意。]]></content>
      <categories>
        <category>iOS 自动布局</category>
      </categories>
      <tags>
        <tag>自动布局 AutoLayout Masnory</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS二维码识别/二维码生成]]></title>
    <url>%2F2017%2F11%2F03%2Fqr-droid%2F</url>
    <content type="text"><![CDATA[前言之前做过一个关于二维码的组件，已发布，现总结下。开发的APP所需支持的最低版本为8.0，最初的方案为扫描使用苹果自带的API实现扫一扫的功能、使用ZXing识别从相册或别人转发的二维码图片。但发现ZXing识别从相册中来的图片性能很差，很多图片识别不了，且耗时较长，遂使用ZBar来实现识别从相册或别人转发的二维码图片。这个组件重要实现了三个功能，扫一扫识别二维码图片、长按图片识别二维码图片和生成二维码图片。首先来看下扫一扫识别二维码图片的代码实现：功能实现扫一扫识别二维码图片12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485- (void)initCapture &#123; AVCaptureDevice* inputDevice = [AVCaptureDevice defaultDeviceWithMediaType:AVMediaTypeVideo]; [inputDevice lockForConfiguration:nil]; if ([inputDevice hasTorch])&#123; inputDevice.torchMode = AVCaptureTorchModeAuto; &#125; AVCaptureFocusMode foucusMode = AVCaptureFocusModeContinuousAutoFocus; if ([inputDevice isFocusModeSupported:foucusMode]) &#123; inputDevice.focusMode = foucusMode; &#125; [inputDevice unlockForConfiguration]; AVCaptureDeviceInput *captureInput = [AVCaptureDeviceInput deviceInputWithDevice:inputDevice error:nil]; if (!captureInput) &#123; //支持的最低版本为iOS8 UIAlertController *alterVC = [UIAlertController alertControllerWithTitle:MUIQRCodeLocalizedString(@"ScanViewController_system_tip") message:MUIQRCodeLocalizedString(@"ScanViewController_camera_permission") preferredStyle:UIAlertControllerStyleAlert]; UIAlertAction *confirmAction = [UIAlertAction actionWithTitle:MUIQRCodeLocalizedString(@"ScanViewController_yes") style:UIAlertActionStyleDefault handler:nil]; [alterVC addAction:confirmAction]; [self presentViewController:alterVC animated:YES completion:nil]; [self.activityView stopAnimating]; [self onVideoStart:nil]; return; &#125; AVCaptureMetadataOutput *captureOutput = [[AVCaptureMetadataOutput alloc] init]; [captureOutput setMetadataObjectsDelegate:self queue:_queue]; self.captureOutput = captureOutput; self.captureSession = [[AVCaptureSession alloc] init]; [self.captureSession addInput:captureInput]; [self.captureSession addOutput:captureOutput]; CGFloat w = 1920.f; CGFloat h = 1080.f; if ([self.captureSession canSetSessionPreset:AVCaptureSessionPreset1920x1080]) &#123; self.captureSession.sessionPreset = AVCaptureSessionPreset1920x1080; &#125; else if ([self.captureSession canSetSessionPreset:AVCaptureSessionPreset1280x720]) &#123; self.captureSession.sessionPreset = AVCaptureSessionPreset1280x720; w = 1280.f; h = 720.f; &#125; else if ([self.captureSession canSetSessionPreset:AVCaptureSessionPreset640x480]) &#123; self.captureSession.sessionPreset = AVCaptureSessionPreset640x480; w = 960.f; h = 540.f; &#125; captureOutput.metadataObjectTypes = [captureOutput availableMetadataObjectTypes]; CGRect bounds = [[UIScreen mainScreen] bounds]; if (!self.prevLayer) &#123; self.prevLayer = [AVCaptureVideoPreviewLayer layerWithSession:self.captureSession]; &#125; self.prevLayer.frame = bounds; self.prevLayer.videoGravity = AVLayerVideoGravityResizeAspectFill; [self.view.layer insertSublayer:self.prevLayer atIndex:0]; //下面代码主要用来设置扫描的聚焦范围，计算rectOfInterest CGFloat p1 = bounds.size.height/bounds.size.width; CGFloat p2 = w/h; CGRect cropRect = CGRectMake(CGRectGetMinX(_cropRect) - kSNReaderScanExpandWidth, CGRectGetMinY(_cropRect) - kSNReaderScanExpandHeight, CGRectGetWidth(_cropRect) + 2*kSNReaderScanExpandWidth, CGRectGetHeight(_cropRect) + 2*kSNReaderScanExpandHeight); // CGRect cropRect = _cropRect; if (fabs(p1 - p2) &lt; 0.00001) &#123; captureOutput.rectOfInterest = CGRectMake(cropRect.origin.y /bounds.size.height, cropRect.origin.x/bounds.size.width, cropRect.size.height/bounds.size.height, cropRect.size.width/bounds.size.width); &#125; else if (p1 &lt; p2) &#123; //实际图像被截取一段高 CGFloat fixHeight = bounds.size.width * w / h; CGFloat fixPadding = (fixHeight - bounds.size.height)/2; captureOutput.rectOfInterest = CGRectMake((cropRect.origin.y + fixPadding)/fixHeight, cropRect.origin.x/bounds.size.width, cropRect.size.height/fixHeight, cropRect.size.width/bounds.size.width); &#125; else &#123; CGFloat fixWidth = bounds.size.height * h / w; CGFloat fixPadding = (fixWidth - bounds.size.width)/2; captureOutput.rectOfInterest = CGRectMake(cropRect.origin.y/bounds.size.height, (cropRect.origin.x + fixPadding)/fixWidth, cropRect.size.height/bounds.size.height, cropRect.size.width/fixWidth); &#125;&#125;识别二维码图片识别二维码图片的功能，最初的方案是使用三方库ZXing来实现，因为ZXing有人在维护，但ZXing识别相册中的二维码图片或本地的图片时，有些图片根本就识别不出来，且耗时较长，所以改为使用ZBar。在网上找到一篇文章再见ZXing 使用系统原生代码处理QRCode,实测发现使用系统原生代码来识别二维码图片时，在，iphone4s，系统为iOS9的手机发现传回来的数组为空。代码如下：12345678910111213141516171819- (NSString *)decodeQRImageWith:(UIImage*)aImage &#123; NSString *qrResult = nil; //iOS8及以上可以使用系统自带的识别二维码图片接口，但此api有问题，在一些机型上detector为nil。 if (iOS8_OR_LATER) &#123; CIContext *context = [CIContext contextWithOptions:nil]; CIDetector *detector = [CIDetector detectorOfType:CIDetectorTypeQRCode context:context options:@&#123;CIDetectorAccuracy:CIDetectorAccuracyHigh&#125;]; CIImage *image = [CIImage imageWithCGImage:aImage.CGImage]; NSArray *features = [detector featuresInImage:image]; CIQRCodeFeature *feature = [features firstObject]; qrResult = feature.messageString; &#125; else &#123; ZBarReaderController* read = [ZBarReaderController new]; CGImageRef cgImageRef = aImage.CGImage; ZBarSymbol* symbol = nil; for(symbol in [read scanImage:cgImageRef]) break; qrResult = symbol.data ; return qrResult; &#125; &#125;无图无真相：detector的值为nil，也就是说1CIDetector *detector = [CIDetector detectorOfType:CIDetectorTypeQRCode context:context options:@&#123;CIDetectorAccuracy:CIDetectorAccuracyHigh&#125;];CIDetector的初始化方法无效。推测是苹果API的问题。生成二维码图片在iOS8及以上版本使用苹果的API生成二维码图片，代码如下：123456789101112131415161718192021222324252627282930313233- (UIImage *)encodeQRImageWithContent:(NSString *)content size:(CGSize)size &#123; UIImage *codeImage = nil; if (iOS8_OR_LATER) &#123; NSData *stringData = [content dataUsingEncoding: NSUTF8StringEncoding]; //生成 CIFilter *qrFilter = [CIFilter filterWithName:@"CIQRCodeGenerator"]; [qrFilter setValue:stringData forKey:@"inputMessage"]; [qrFilter setValue:@"M" forKey:@"inputCorrectionLevel"]; UIColor *onColor = [UIColor blackColor]; UIColor *offColor = [UIColor whiteColor]; //上色 CIFilter *colorFilter = [CIFilter filterWithName:@"CIFalseColor" keysAndValues: @"inputImage",qrFilter.outputImage, @"inputColor0",[CIColor colorWithCGColor:onColor.CGColor], @"inputColor1",[CIColor colorWithCGColor:offColor.CGColor], nil]; CIImage *qrImage = colorFilter.outputImage; CGImageRef cgImage = [[CIContext contextWithOptions:nil] createCGImage:qrImage fromRect:qrImage.extent]; UIGraphicsBeginImageContext(size); CGContextRef context = UIGraphicsGetCurrentContext(); CGContextSetInterpolationQuality(context, kCGInterpolationNone); CGContextScaleCTM(context, 1.0, -1.0); CGContextDrawImage(context, CGContextGetClipBoundingBox(context), cgImage); codeImage = UIGraphicsGetImageFromCurrentImageContext(); UIGraphicsEndImageContext(); CGImageRelease(cgImage); &#125; else &#123; codeImage = [QRCodeGenerator qrImageForString:content imageSize:size.width]; &#125; return codeImage; &#125;iOS8以下使用libqrencode库来生成二维码图片。代码完善2015年12月11日QA测试发现，服务端生成的二维码，使用ZBar识别不出来，但将这张图片保存到相册，然后发送就可以识别出来。最初的想法是要服务端修改生成的二维码，但安卓能够识别出来，此路不通，那只有看ZBar的源码了。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263- (id &lt;NSFastEnumeration&gt;) scanImage: (CGImageRef) image &#123; timer_start; int nsyms = [self scanImage: image withScaling: 0]; //没有识别出来，判断CGImageRef对象的宽和高是否大于640，大于或等于的话进行缩放再进行扫描 if(!nsyms &amp;&amp; CGImageGetWidth(image) &gt;= 640 &amp;&amp; CGImageGetHeight(image) &gt;= 640) // make one more attempt for close up, grainy images nsyms = [self scanImage: image withScaling: .5]; NSMutableArray *syms = nil; if(nsyms) &#123; // quality/type filtering int max_quality = MIN_QUALITY; for(ZBarSymbol *sym in scanner.results) &#123; zbar_symbol_type_t type = sym.type; int quality; if(type == ZBAR_QRCODE) quality = INT_MAX; else quality = sym.quality; if(quality &lt; max_quality) &#123; zlog(@" type=%d quality=%d &lt; %d\n", type, quality, max_quality); continue; &#125; if(max_quality &lt; quality) &#123; max_quality = quality; if(syms) [syms removeAllObjects]; &#125; zlog(@" type=%d quality=%d\n", type, quality); if(!syms) syms = [NSMutableArray arrayWithCapacity: 1]; [syms addObject: sym]; &#125; &#125; zlog(@"read %d filtered symbols in %gs total\n", (!syms) ? 0 : [syms count], timer_elapsed(t_start, timer_now())); return(syms); &#125; if(max_quality &lt; quality) &#123; max_quality = quality; if(syms) [syms removeAllObjects]; &#125; zlog(@" type=%d quality=%d\n", type, quality); if(!syms) syms = [NSMutableArray arrayWithCapacity: 1]; [syms addObject: sym]; &#125; &#125; zlog(@"read %d filtered symbols in %gs total\n", (!syms) ? 0 : [syms count], timer_elapsed(t_start, timer_now())); return(syms);&#125;在这里就产生了一个解决有些二维码图片识别不出来的解决思路：将传过来的UIImage的宽和高设置为640，识别不出来再进行缩放识别。修改UIImage的代码如下：123456789101112-(UIImage *)TransformtoSize:(CGSize)Newsize &#123; // 创建一个bitmap的context UIGraphicsBeginImageContext(Newsize); // 绘制改变大小的图片 [self drawInRect:CGRectMake(0, 0, Newsize.width, Newsize.height)]; // 从当前context中创建一个改变大小后的图片 UIImage *TransformedImg=UIGraphicsGetImageFromCurrentImageContext(); // 使当前的context出堆栈 UIGraphicsEndImageContext(); // 返回新的改变大小后的图片 return TransformedImg;&#125;这样类似于将ZXing中的tryHard设置为YES。识别不出来的二维码图片就可以识别了。2016年5月20日遗留的bug: 点击进入扫一扫界面，退出，再进入，这样重复5次左右，扫一扫之前的界面的会出现卡顿。原因：多次进入扫一扫界面，再退出，因此界面未被系统回收，captureSession对象一直在运行，会造成内存泄露，引起上一个界面卡顿。解决方案：在视图将要消失的时候，确保captureSession对象停止运行。123456- (void)viewWillDisappear:(BOOL)animated &#123; [super viewWillDisappear:animated]; if ([self.captureSession isRunning]) &#123; [self.captureSession stopRunning]; &#125;&#125;2018年4月28日识别二维码图片优化近期通过bugly收集卡顿问题发现，二维码组件在识别二维码图片时，会出现卡顿问题。为优化识别速度，采用了三种方案，并分别进行测试，并对测试数据进行分析，最终挑选出最优的方案。任务A：使用系统提供的CoreImage的CIDetector接口去识别二维码图片，返回对应的字符串；任务B：使用zbar中的方法去识别二维码图片，返回对应的字符串。1234567891011121314151617181920212223242526//任务A+ (NSString *)useSystemMethodDecodeImage:(UIImage *)image &#123; NSString *resultString = nil; CIDetector *detector = [CIDetector detectorOfType:CIDetectorTypeQRCode context:nil options:@&#123;CIDetectorAccuracy:CIDetectorAccuracyHigh&#125;]; if (detector) &#123; CIImage *ciImage = [CIImage imageWithCGImage:image.CGImage]; NSArray *features = [detector featuresInImage:ciImage]; CIQRCodeFeature *feature = [features firstObject]; resultString = feature.messageString; &#125; return resultString;&#125;//任务B+ (NSString *)useZbarMethodDecodeImage:(UIImage *)image &#123; UIImage *decodeImage = image; if (decodeImage.size.width &lt; 641) &#123; decodeImage = [decodeImage TransformtoSize:CGSizeMake(640, 640)]; &#125; QRCodeZBarReaderController* read = [QRCodeZBarReaderController new]; CGImageRef cgImageRef = decodeImage.CGImage; QRCodeZBarSymbol *symbol = nil; for(symbol in [read scanImage:cgImageRef]) break; return symbol.data;&#125;方案A：先执行任务A，如果获取到的字符串为空，再执行任务B。123456789101112131415161718192021222324+ (NSString *)planOneDecodeWithImage:(UIImage *)image index:(NSInteger)index&#123; NSMutableString *costTimeInfo = [NSMutableString stringWithFormat:@"%ld\r\n",index]; CFAbsoluteTime startTime = CFAbsoluteTimeGetCurrent(); NSString *detectorString = [MUIQRCodeDecoder useSystemMethodDecodeImage:image]; CFAbsoluteTime detectorCostTime = (CFAbsoluteTimeGetCurrent() - startTime); [costTimeInfo appendString:[NSString stringWithFormat:@"detector : %f ms\r\n",detectorCostTime *1000.0]]; NSAssert(detectorString.length &gt; 0, @"detector fail!"); CFAbsoluteTime zbarStartTime = CFAbsoluteTimeGetCurrent(); NSString *zbarSymbolString = [MUIQRCodeDecoder useZbarMethodDecodeImage:image]; NSAssert(zbarSymbolString.length &gt; 0, @"zbar fail!"); CFAbsoluteTime zbarCostTime = (CFAbsoluteTimeGetCurrent() - zbarStartTime); [costTimeInfo appendString:[NSString stringWithFormat:@"zbar : %f ms\r\n",zbarCostTime *1000.0]]; CFAbsoluteTime totalCostTime = (CFAbsoluteTimeGetCurrent() - startTime); [costTimeInfo appendString:[NSString stringWithFormat:@"total cost : %f ms\r\n",totalCostTime *1000.0]]; [costTimeInfo appendString:[NSString stringWithFormat:@"detectorString : %@ ms\r\n",detectorString]]; [costTimeInfo appendString:[NSString stringWithFormat:@"zbarSymbolString : %@ ms\r\n",zbarSymbolString]]; return [costTimeInfo copy];&#125;方案B：同时执行任务A和任务B，两者均执行完后，返回识别的结果；123456789101112131415161718192021222324252627282930313233343536+ (NSString *)planTwoDecodeWithImage:(UIImage *)image index:(NSInteger)index &#123; __block NSMutableString *costTimeInfo = [NSMutableString stringWithFormat:@"%ld\r\n",index]; __block NSString *detectorString = nil; __block NSString *zbarSymbolString = nil; CFAbsoluteTime startTime = CFAbsoluteTimeGetCurrent(); dispatch_semaphore_t semaphore = dispatch_semaphore_create(0); dispatch_group_t group = dispatch_group_create(); dispatch_group_async(group, dispatch_get_global_queue(0,0), ^&#123; detectorString = [MUIQRCodeDecoder useSystemMethodDecodeImage:image]; NSAssert(detectorString.length &gt; 0, @"detector fail!"); CFAbsoluteTime costTime = (CFAbsoluteTimeGetCurrent() - startTime); [costTimeInfo appendString:[NSString stringWithFormat:@"detector : %f ms\r\n",costTime *1000.0]]; &#125;); dispatch_group_async(group, dispatch_get_global_queue(0,0), ^&#123; zbarSymbolString = [MUIQRCodeDecoder useZbarMethodDecodeImage:image]; NSAssert(zbarSymbolString.length &gt; 0, @"zbar fail!"); CFAbsoluteTime costTime = (CFAbsoluteTimeGetCurrent() - startTime); [costTimeInfo appendString:[NSString stringWithFormat:@"zbar : %f ms\r\n",costTime *1000.0]]; &#125;); dispatch_group_notify(group, dispatch_get_global_queue(0,0), ^&#123; dispatch_semaphore_signal(semaphore); &#125;); dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER); CFAbsoluteTime totalCostTime = (CFAbsoluteTimeGetCurrent() - startTime); [costTimeInfo appendString:[NSString stringWithFormat:@"total cost : %f ms\r\n",totalCostTime *1000.0]]; [costTimeInfo appendString:[NSString stringWithFormat:@"detectorString : %@ ms\r\n",detectorString]]; [costTimeInfo appendString:[NSString stringWithFormat:@"zbarSymbolString : %@ ms\r\n",zbarSymbolString]]; return [costTimeInfo copy];&#125;方案C：同时执行任务A和任务B1、任务A先执行完且识别成功，返回识别结果；2、任务B先执行完且识别成功，返回识别结果；3、任务A和任务B均识别失败，两者均执行完后，返回识别的结果。+ (NSString *)planThreeDecodeWithImage:(UIImage *)image index:(NSInteger)index { __block NSMutableString *costTimeInfo = [NSMutableString stringWithFormat:@"%ld\r\n",index]; __block NSString *detectorString = nil; __block NSString *zbarSymbolString = nil; __block BOOL isNeedSendSignal = YES; CFAbsoluteTime startTime = CFAbsoluteTimeGetCurrent(); dispatch_semaphore_t semaphore = dispatch_semaphore_create(0); dispatch_group_t group = dispatch_group_create(); dispatch_group_async(group, dispatch_get_global_queue(0,0), ^{ detectorString = [MUIQRCodeDecoder useSystemMethodDecodeImage:image]; //NSAssert(detectorString.length &gt; 0, @"detector fail!"); CFAbsoluteTime costTime = (CFAbsoluteTimeGetCurrent() - startTime); [costTimeInfo appendString:[NSString stringWithFormat:@"detector : %f ms\r\n",costTime *1000.0]]; if (detectorString.length &gt; 0 &amp;&amp; isNeedSendSignal) { isNeedSendSignal = NO; dispatch_semaphore_signal(semaphore); } }); dispatch_group_async(group, dispatch_get_global_queue(0,0), ^{ zbarSymbolString = [MUIQRCodeDecoder useZbarMethodDecodeImage:image]; //NSAssert(zbarSymbolString.length &gt; 0, @"zbar fail!"); CFAbsoluteTime costTime = (CFAbsoluteTimeGetCurrent() - startTime); [costTimeInfo appendString:[NSString stringWithFormat:@"zbar : %f ms\r\n",costTime *1000.0]]; if (zbarSymbolString.length &gt; 0 &amp;&amp; isNeedSendSignal) { isNeedSendSignal = NO; dispatch_semaphore_signal(semaphore); } }); dispatch_group_notify(group, dispatch_get_global_queue(0,0), ^{ if (isNeedSendSignal) { dispatch_semaphore_signal(semaphore); } }); dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER); CFAbsoluteTime totalCostTime = (CFAbsoluteTimeGetCurrent() - startTime); [costTimeInfo appendString:[NSString stringWithFormat:@"total cost : %f ms\r\n",totalCostTime *1000.0]]; [costTimeInfo appendString:[NSString stringWithFormat:@"detectorString : %@ ms\r\n",detectorString]]; [costTimeInfo appendString:[NSString stringWithFormat:@"zbarSymbolString : %@ ms\r\n",zbarSymbolString]]; return [costTimeInfo copy]; } 测试数据如下所示:(取了前10张图片）分析测试数据发现：1、在测试第一张二维码图片时，总耗时均较大，如果第一次识别使用的是系统方法，耗时超过500ms，这也是为什么会出现卡顿的原因；2、使用系统方法去识别二维码图片时，如果不是第一次去识别，耗时较小，在65ms以内；3、使用zbar的方法去识别二维码图片，耗时均值在200ms以内；4、在方案C中，如果第一次使用系统方法，耗时为226ms。总结得出，从优化卡顿问题的角度出发，使用方案C最优，同时发现，如果使用系统方法能识别出二维码图片，在初始化之后（也就是第二次使用），耗时最短。同时因为在实际的使用场景中，图片是一张一张识别的，识别过程有一个间隔时间，如果已经使用系统方法识别过二维码图片，那下次识别就能达到最优。所以使用方案C的话，最差情况均值在200ms左右，最好的情况和方案A中第二次使用系统方法耗时基本一致。综合考虑，使用方案C。小结在实际的项目开发过程中，设想的情况和实际情况会存在偏差，需要自己时刻使用性能调优工具，根据数据去进行优化，而不能想当然的认为某种方式是最优的。源码和demo请点这里参考的文章链接如下再见ZXing 使用系统原生代码处理QRCodeIOS二维码扫描,你需要注意的两件事Zbar算法流程介绍]]></content>
      <categories>
        <category>iOS 开发</category>
      </categories>
      <tags>
        <tag>二维码 图片识别</tag>
      </tags>
  </entry>
</search>
